<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LINQ in C# 14 with .NET 10: From Beginner to Expert</title>
    <link rel="icon" type="image/png"
        href="https://ik.imagekit.io/quadrate/assets/img/QTS%20Primary%20Logo.png?updatedAt=1744406831895">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-okaidia.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 100%;
            overflow-x: hidden;
        }

        .book-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .chapter {
            margin-bottom: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #e5e7eb;
        }

        .chapter:first-of-type {
            border-top: none;
        }

        .section {
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            border-radius: 0.375rem;
            margin: 1rem 0;
            overflow-x: auto;
            background-color: #2d2d2d;
            /* Okaidia background */
            padding: 1em;
        }

        pre code {
            display: block;
            white-space: pre;
            color: #f8f8f2;
            /* Okaidia text color */
        }

        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #1a56db;
        }

        h2 {
            font-size: 1.875rem;
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #1e429f;
        }

        h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: #2563eb;
        }

        h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
            color: #3b82f6;
        }

        p {
            margin-bottom: 1rem;
        }

        .toc-link {
            color: #3b82f6;
            text-decoration: none;
        }

        .toc-link:hover {
            text-decoration: underline;
        }

        .note {
            background-color: #f3f4f6;
            border-left: 4px solid #3b82f6;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0.375rem;
        }

        .warning {
            background-color: #fff7ed;
            border-left: 4px solid #f97316;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0.375rem;
        }

        .tip {
            background-color: #ecfdf5;
            border-left: 4px solid #10b981;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0.375rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th,
        td {
            padding: 0.75rem;
            border: 1px solid #e5e7eb;
        }

        th {
            background-color: #f9fafb;
            font-weight: 600;
            text-align: left;
        }

        .code-result {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            padding: 0.75rem;
            margin-top: -0.5rem;
            margin-bottom: 1rem;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
        }

        /* Utility Classes for Examples */
        .example-class-definitions {
            background-color: #eef2ff;
            border: 1px solid #c7d2fe;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-top: 1rem;
            margin-bottom: 1rem;
        }

        .example-class-definitions h5 {
            color: #4338ca;
            margin-bottom: 0.5rem;
        }
    </style>
</head>

<body>
    <div class="book-container">
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold mb-2">LINQ in C# 14 with .NET 10</h1>
            <h2 class="text-2xl font-semibold mb-4">From Beginner to Expert</h2>
            <p class="text-gray-600">A comprehensive guide to mastering LINQ with the latest C# features</p>
        </header>

        <div class="toc mb-12">
            <h2 id="table-of-contents" class="text-2xl font-bold mb-4">Table of Contents</h2>

            <h3 class="text-xl font-semibold mt-6 mb-2">Part 1: Foundations of C# and LINQ</h3>
            <ul class="list-disc pl-8 mb-4">
                <li><a href="#introduction" class="toc-link">Introduction to C# 14 and .NET 10</a></li>
                <li><a href="#csharp-basics" class="toc-link">C# Basics for LINQ Beginners</a></li>
                <li><a href="#getting-started" class="toc-link">Getting Started with LINQ</a></li>
            </ul>

            <h3 class="text-xl font-semibold mt-6 mb-2">Part 2: LINQ Fundamentals</h3>
            <ul class="list-disc pl-8 mb-4">
                <li><a href="#query-syntax" class="toc-link">Query Syntax Deep Dive</a></li>
                <li><a href="#method-syntax" class="toc-link">Method Syntax and Standard Query Operators</a></li>
                <li><a href="#deferred-execution" class="toc-link">Deferred Execution and Performance</a></li>
            </ul>

            <h3 class="text-xl font-semibold mt-6 mb-2">Part 3: Intermediate LINQ Techniques</h3>
            <ul class="list-disc pl-8 mb-4">
                <li><a href="#advanced-operators" class="toc-link">Advanced Query Operators</a></li>
                <li><a href="#working-collections" class="toc-link">Working with Collections</a></li>
                <li><a href="#best-practices" class="toc-link">LINQ Best Practices</a></li>
            </ul>

            <h3 class="text-xl font-semibold mt-6 mb-2">Part 4: Advanced LINQ and C# 14 Integration</h3>
            <ul class="list-disc pl-8 mb-4">
                <li><a href="#csharp14-features" class="toc-link">LINQ with C# 14 Features</a></li>
                <li><a href="#linq-to-sql" class="toc-link">Querying Databases with LINQ to SQL (EF Core)</a></li>
                <li><a href="#custom-operators" class="toc-link">Custom LINQ Operators</a></li>
            </ul>

            <h3 class="text-xl font-semibold mt-6 mb-2">Part 5: Expert-Level Topics</h3>
            <ul class="list-disc pl-8 mb-4">
                <li><a href="#performance" class="toc-link">Performance Optimization</a></li>
                <li><a href="#real-world" class="toc-link">LINQ in Real-World Applications</a></li>
                <li><a href="#future" class="toc-link">Future of LINQ in C#</a></li>
            </ul>

            <h3 class="text-xl font-semibold mt-6 mb-2">Appendices</h3>
            <ul class="list-disc pl-8 mb-4">
                <li><a href="#appendix-a" class="toc-link">Appendix A: LINQ Quick Reference Guide</a></li>
                <li><a href="#appendix-b" class="toc-link">Appendix B: C# 14 Cheatsheet</a></li>
                <li><a href="#appendix-c" class="toc-link">Appendix C: Case Studies</a></li>
            </ul>
        </div>

        <!-- Example Class Definitions for use throughout the book -->
        <div class="example-class-definitions">
            <h5 class="text-lg font-medium">Supporting Example Classes & Records</h5>
            <pre><code class="language-csharp">// Used in various examples
public class Person { public string Name { get; set; } = ""; public int Age { get; set; } }
public class Product { public int Id { get; set; } public string Name { get; set; } = ""; public decimal Price { get; set; } public string Category { get; set; } = ""; public bool InStock { get; set; } public bool IsActive { get; set; } public bool IsDiscontinued { get; set; } }
public class Category { public int Id { get; set; } public string Name { get; set; } = ""; }
public class Employee { public int Id { get; set; } public string Name { get; set; } = ""; public string Department { get; set; } = ""; public decimal Salary { get; set; } public int Age { get; set; } public int YearsOfService { get; set; }}
public class Sale { public int ProductId { get; set; } public string Category { get; set; } = ""; public string Region { get; set; } = ""; public decimal Amount { get; set; } }
public class Customer { public int Id { get; set; } public string Name { get; set; } = ""; public string FullName { get { return Name; } } public string City { get; set; } = ""; public int Orders { get; set; } public decimal TotalPurchases { get; set; } public bool IsActive { get; set; } public string Email { get; set; } = ""; public string Phone { get; set; } = ""; public DateTime JoinDate { get; set; } public List&lt;Order&gt; OrderList { get; set; } = new List&lt;Order&gt;(); }
public class Order { public int Id { get; set; } public decimal Total { get; set; } public DateTime Date { get; set; } public List&lt;OrderItem&gt; Items { get; set; } = []; public string Status { get; set; } = ""; public DateTime OrderDate { get; set; } public decimal TotalAmount { get; set; } public int CustomerId { get; set; } public Customer? Customer { get; set; } }
public class OrderItem { public int ProductId { get; set; } public string Name { get; set; } = ""; public decimal Price { get; set; } public int Quantity { get; set; } public decimal UnitPrice { get; set; } }
public record ProductSummary(string Name, decimal Price, string Category);
public record CustomerRecord(int Id, string Name, int OrderCount, decimal TotalSpent);
public record CategorySummary(string Name, int Count, decimal TotalValue, decimal AveragePrice);
public class Department { public string Name { get; set; } = ""; public string Location { get; set; } = ""; }
public class Item { public string Name { get; set; } = ""; public decimal Price { get; set; } }
public record StockPrice(DateTime Date, decimal Price);

// For custom operators example
public class Page&lt;T&gt; { public IReadOnlyList&lt;T&gt; Items { get; } public Page(IEnumerable&lt;T&gt; items) { Items = items.ToList(); } }
public record ValidationResult(bool IsValid, IReadOnlyList&lt;object&gt; InvalidItems, string ErrorMessage);
public class FileSystemItem { public string Name { get; set; } = ""; public bool IsDirectory { get; set; } public List&lt;FileSystemItem&gt; Children { get; set; } = []; }

// For EF Core example
public class ECommerceContext : Microsoft.EntityFrameworkCore.DbContext
{
    public Microsoft.EntityFrameworkCore.DbSet&lt;Customer&gt; Customers { get; set; } = null!;
    public Microsoft.EntityFrameworkCore.DbSet&lt;Order&gt; Orders { get; set; } = null!;
    public Microsoft.EntityFrameworkCore.DbSet&lt;OrderItem&gt; OrderItems { get; set; } = null!;
    public Microsoft.EntityFrameworkCore.DbSet&lt;Product&gt; Products { get; set; } = null!;

    protected override void OnConfiguring(Microsoft.EntityFrameworkCore.DbContextOptionsBuilder optionsBuilder)
    {
        // Use InMemory database for simple examples without real DB setup
        optionsBuilder.UseInMemoryDatabase("ECommerceDbExample");
    }
     protected override void OnModelCreating(Microsoft.EntityFrameworkCore.ModelBuilder modelBuilder)
     {
         // Configure relationships if needed
         modelBuilder.Entity<Customer>().HasMany(c => c.OrderList).WithOne(o => o.Customer).HasForeignKey(o => o.CustomerId);
         modelBuilder.Entity<Order>().HasMany(o => o.Items).WithOne().HasForeignKey("OrderId"); // Example foreign key
     }
}

// Dummy methods used in examples
public static class ExampleData
{
    public static List&lt;Order&gt; GetLargeOrderList() => Enumerable.Range(1, 1000).Select(i => new Order { Id = i, Total = i * 10.5m, Date = DateTime.Now.AddDays(-i) }).ToList();
    public static List&lt;Item&gt; GetLargeItemList() => Enumerable.Range(1, 1000).Select(i => new Item { Name = $"Item {i}", Price = i * 1.1m }).ToList();
    public static List&lt;Product&gt; GetProducts() => [ new Product { Id = 1, Name = "Laptop", Price = 1200, Category = "Electronics", InStock = true }, new Product { Id = 2, Name = "Mouse", Price = 25, Category = "Electronics", InStock = true }, new Product { Id = 3, Name = "Desk", Price = 300, Category = "Furniture", InStock = false }, new Product { Id = 4, Name = "Chair", Price = 150, Category = "Furniture", InStock = true } ];
    public static List&lt;Customer&gt; GetMillionsOfCustomers() => Enumerable.Range(1, 10000).Select(i => new Customer { Id = i, Name = $"Cust {i}", TotalPurchases = i % 100 * 150m }).ToList(); // Simulate large list
    public static bool SometimesThrows(Customer c) { if (c.Id % 100 == 0) throw new Exception("Simulated error"); return c.TotalPurchases > 5000; }
    public static void ProcessProduct(Product p) { /* process */ }
    public static IEnumerable&lt;ProductPrice&gt; GetProductPrices() => Enumerable.Range(1, 5000).Select(i => new ProductPrice { ProductId = i, Amount = (i % 500) + 10m });
    public static List&lt;StockPrice&gt; GetStockPrices() => Enumerable.Range(1, 100).Select(i => new StockPrice(DateTime.Today.AddDays(i - 100), 100 + (decimal)(Math.Sin(i / 10.0) * 10))).ToList();
    public static IEnumerable&lt;Product&gt; GetFeaturedProducts() => GetProducts().Take(1);
    public static IEnumerable&lt;Product&gt; GetDefaultProducts() => [new Product { Id = 99, Name = "Default", Price = 10, Category = "Misc", InStock = true }];
    public static void ProcessProductBatch(IEnumerable&lt;Product&gt; batch) { /* process batch */ }
    public static FileSystemItem GetFileSystemRoot() => new FileSystemItem { Name = "C:", IsDirectory = true, Children = [ new FileSystemItem { Name = "Docs", IsDirectory = true, Children = [ new FileSystemItem { Name = "report.docx", IsDirectory = false } ] }, new FileSystemItem { Name = "image.jpg", IsDirectory = false } ] };
    public static bool ProcessOrder(Order o) { return o.Id % 10 != 0; /* Simulate processing, fail 1 in 10 */ }
    public static List&lt;Product&gt; GetAllProducts() => GetProducts();
    public static void DisplayProductPage(IEnumerable&lt;Product&gt; pageItems) { foreach(var p in pageItems) Console.WriteLine(p.Name); }
    public static void ProcessLine(string line) { Console.WriteLine($"Processing: {line}"); }
    public static void ProcessBatch(IEnumerable&lt;object&gt; batch) { Console.WriteLine($"Processing batch of {batch.Count()} items."); }
    public record ProductPrice(int ProductId, decimal Amount);
}
</code></pre>
        </div>


        <!-- Part 1: Foundations of C# and LINQ -->
        <div class="chapter">
            <h2 id="introduction" class="text-3xl font-bold">Part 1: Foundations of C# and LINQ</h2>

            <div class="section">
                <h3 class="text-2xl font-semibold">Introduction to C# 14 and .NET 10</h3>

                <p>
                    C# 14 and .NET 10 represent the latest evolution in Microsoft's development platform, bringing a
                    host of new features and performance improvements. This chapter introduces these technologies and
                    sets the stage for our exploration of LINQ.
                </p>

                <h4 class="text-xl font-medium mt-6">Overview of C# 14 Features (Based on recent trends)</h4>

                <p>
                    While specific C# 14 features are speculative until officially announced, we can anticipate trends
                    based on recent releases. C# continues to focus on simplifying code, improving performance, and
                    enhancing pattern matching and data handling. Potential areas include:
                </p>

                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Further Collection Literal Enhancements:</strong> Building on collection expressions
                        introduced in C# 12.</li>
                    <li><strong>Refined Primary Constructors:</strong> Wider adoption and potential improvements.</li>
                    <li><strong>Enhanced Pattern Matching:</strong> More sophisticated patterns, potentially including
                        active patterns or improvements to list patterns.</li>
                    <li><strong>Improved Async/Await Support:</strong> Simplifications or performance boosts for
                        asynchronous code.</li>
                    <li><strong>Expanded Roles for Records and Structs:</strong> More features for concise data
                        modeling.</li>
                </ul>

                <h5 class="text-lg font-medium mt-4">Example: Collection Expressions (from C# 12, expected to be key in
                    C# 14+)</h5>
                <pre><code class="language-csharp">// Before C# 12
List&lt;int&gt; numbersList = new List&lt;int&gt; { 1, 2, 3, 4, 5 };
int[] numbersArray = new int[] { 1, 2, 3, 4, 5 };
Dictionary&lt;string, int&gt; agesDict = new Dictionary&lt;string, int&gt;
{
    { "Alice", 30 },
    { "Bob", 25 },
    { "Charlie", 35 }
};

// With C# 12+ collection expressions
List&lt;int&gt; numbersList = [1, 2, 3, 4, 5];
int[] numbersArray = [1, 2, 3, 4, 5];
Dictionary&lt;string, int&gt; agesDict = new() { ["Alice"] = 30, ["Bob"] = 25, ["Charlie"] = 35 };
// Or more concisely for dictionaries:
Dictionary&lt;string, int&gt; agesDictConcise = ["Alice": 30, "Bob": 25, "Charlie": 35];

// Type inference with collection expressions
var numbers = [1, 2, 3, 4, 5]; // Inferred as int[] by default
IEnumerable&lt;int&gt; numbersEnumerable = [1, 2, 3]; // Can target different collection types
</code></pre>

                <h4 class="text-xl font-medium mt-6">Overview of .NET 10 (Based on recent trends)</h4>
                <p>
                    .NET continues its yearly release cadence, focusing on performance, unification across platforms
                    (web, desktop, mobile, cloud), and developer productivity. Key themes for .NET 10 likely include:
                </p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Performance Improvements:</strong> JIT compilation, garbage collection, and core library
                        optimizations.</li>
                    <li><strong>Cloud-Native Enhancements:</strong> Better support for containerization, serverless, and
                        microservices.</li>
                    <li><strong>AI Integration:</strong> Enhanced libraries and tools for integrating AI capabilities.
                    </li>
                    <li><strong>MAUI and Blazor Evolution:</strong> Continued development for cross-platform UI and web
                        applications.</li>
                    <li><strong>Tooling Enhancements:</strong> Improvements in Visual Studio, VS Code, and the `dotnet`
                        CLI.</li>
                </ul>

                <h4 class="text-xl font-medium mt-6">Setting up the Development Environment</h4>
                <p>
                    To follow along with the examples in this book, you'll need the .NET SDK (version 10 or later, when
                    available) and a code editor.
                </p>
                <h5 class="text-lg font-medium mt-4">Installing the .NET SDK</h5>
                <ol class="list-decimal pl-8 mb-4">
                    <li>Download the .NET SDK (Software Development Kit) from the official Microsoft .NET website (<a
                            href="https://dotnet.microsoft.com/download" class="toc-link"
                            target="_blank">dotnet.microsoft.com/download</a>). Ensure you get the SDK, not just the
                        runtime.</li>
                    <li>Follow the installation instructions for your operating system (Windows, macOS, or Linux).</li>
                    <li>Verify the installation by opening a terminal or command prompt and running:
                        <code>dotnet --version</code>. This should display the installed SDK version.
                    </li>
                </ol>

                <h5 class="text-lg font-medium mt-4">Choosing a Code Editor</h5>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Visual Studio 2022/2025 (Windows/Mac):</strong> A full-featured Integrated Development
                        Environment (IDE) with excellent debugging, IntelliSense, and project management tools.
                        Recommended for most users. Ensure the ".NET Desktop Development" or "ASP.NET and web
                        development" workload is installed.</li>
                    <li><strong>Visual Studio Code (Windows/Mac/Linux):</strong> A lightweight, powerful, and extensible
                        code editor. Requires installing the C# Dev Kit extension for the best C# development
                        experience.</li>
                    <li><strong>JetBrains Rider (Cross-platform):</strong> A popular paid alternative IDE with strong C#
                        and .NET support.</li>
                </ul>

                <div class="tip">
                    <strong>Tip:</strong> Create a new console project to test your setup:
                    <pre><code class="language-bash">dotnet new console -o MyLinqApp
cd MyLinqApp
dotnet run</code></pre>
                    This should compile and run a simple "Hello, World!" application.
                </div>
            </div>

            <div class="section">
                <h3 id="csharp-basics" class="text-2xl font-semibold">C# Basics for LINQ Beginners</h3>

                <p>
                    Before diving into LINQ, let's review some C# fundamentals that form the foundation for
                    understanding LINQ queries. LINQ relies heavily on features like collections, lambda expressions,
                    delegates, generics, and extension methods.
                </p>

                <h4 class="text-xl font-medium mt-6">Variables, Data Types, and Collections</h4>
                <h5 class="text-lg font-medium mt-4">Basic Types and Variables</h5>
                <pre><code class="language-csharp">// Variable declaration and initialization
int count = 10;           // Integer
string message = "Hello"; // String
decimal price = 99.95m; // Decimal for currency
bool isActive = true;    // Boolean
DateTime today = DateTime.Now; // Date and Time

// Using var for implicit typing (type is inferred by the compiler)
var score = 95;         // Inferred as int
var productName = "Gadget"; // Inferred as string
</code></pre>

                <h5 class="text-lg font-medium mt-4">Collections in C#</h5>
                <p>
                    Collections are fundamental to LINQ as they provide the data sources for queries. The most common
                    collection types include:
                </p>
                <pre><code class="language-csharp">// Arrays (fixed size)
int[] numbersArray = [1, 2, 3, 4, 5]; // Using collection expression

// Lists (dynamic size)
List&lt;string&gt; namesList = ["Alice", "Bob", "Charlie"]; // Using collection expression

// Dictionaries (key-value pairs)
Dictionary&lt;string, int&gt; scoresDict = ["Alice": 95, "Bob": 87, "Charlie": 92];

// Other useful collection types
HashSet&lt;int&gt; uniqueNumbers = [1, 2, 3, 4, 5]; // Stores unique elements, fast lookups
Queue&lt;string&gt; processingQueue = new(); // First-In, First-Out (FIFO)
processingQueue.Enqueue("Task1");
processingQueue.Enqueue("Task2");
Stack&lt;int&gt; undoStack = new(); // Last-In, First-Out (LIFO)
undoStack.Push(1);
undoStack.Push(2);
</code></pre>

                <h5 class="text-lg font-medium mt-4">Lambda Expressions</h5>
                <p>
                    Lambda expressions are crucial for LINQ as they provide a concise way to define inline anonymous
                    functions. They're extensively used in LINQ's method syntax.
                </p>
                <pre><code class="language-csharp">// Basic lambda syntax: (input-parameters) => expression
// Or for multiple statements: (input-parameters) => { statement; statement; ... return result; }

// Simple lambda expression assigned to a Func delegate
Func&lt;int, int&gt; square = x => x * x;
Console.WriteLine($"Square of 5: {square(5)}"); // Output: Square of 5: 25

// Lambda with multiple parameters
Func&lt;int, int, int&gt; multiply = (x, y) => x * y;
Console.WriteLine($"3 * 4: {multiply(3, 4)}"); // Output: 3 * 4: 12

// Lambda with no parameters
Action printHello = () => Console.WriteLine("Hello!");
printHello(); // Output: Hello!

// Lambda with a statement block
Func&lt;int, string&gt; checkGrade = score => {
    if (score >= 90) return "A";
    if (score >= 80) return "B";
    if (score >= 70) return "C";
    return "Fail"; // Implicit else
};
Console.WriteLine($"Grade for 85: {checkGrade(85)}"); // Output: Grade for 85: B

// Lambdas used directly in LINQ (very common)
List&lt;int&gt; numbers = [1, 2, 3, 4, 5, 6];
var evenNumbers = numbers.Where(n => n % 2 == 0); // n => n % 2 == 0 is a lambda
Console.WriteLine($"Even numbers: {string.Join(", ", evenNumbers)}"); // Output: Even numbers: 2, 4, 6
</code></pre>

                <h4 class="text-xl font-medium mt-6">Delegates, Generics, and Extension Methods</h4>

                <h5 class="text-lg font-medium mt-4">Delegates</h5>
                <p>
                    Delegates are type-safe function pointers in C#. They define the signature of a method. LINQ heavily
                    relies on predefined generic delegate types like <code>Func&lt;...&gt;</code> (for methods returning
                    a value) and <code>Action&lt;...&gt;</code> (for methods returning void). Lambda expressions are
                    often used to create instances of these delegate types inline.
                </p>
                <pre><code class="language-csharp">// Custom delegate declaration
delegate int MathOperation(int x, int y);

// Method matching the delegate signature
static int Add(int a, int b) => a + b;
static int Subtract(int a, int b) => a - b;

// Using the custom delegate
MathOperation op1 = Add;
MathOperation op2 = Subtract;
Console.WriteLine($"10 + 5 = {op1(10, 5)}"); // Output: 10 + 5 = 15
Console.WriteLine($"10 - 5 = {op2(10, 5)}"); // Output: 10 - 5 = 5

// Using predefined Func and Action delegates (more common with LINQ)
Func&lt;int, int, int&gt; multiplyFunc = (a, b) => a * b; // Returns int
Action&lt;string&gt; displayAction = message => Console.WriteLine(message); // Returns void

Console.WriteLine($"4 * 5 = {multiplyFunc(4, 5)}");  // Output: 4 * 5 = 20
displayAction("Using predefined delegates!"); // Output: Using predefined delegates!

// Example: Where method expects a Func&lt;T, bool&gt; delegate
Func&lt;int, bool&gt; isEvenPredicate = n => n % 2 == 0;
var evenNumbers = numbers.Where(isEvenPredicate);
</code></pre>

                <h5 class="text-lg font-medium mt-4">Generics</h5>
                <p>
                    Generics allow you to define type-safe data structures and methods without committing to specific
                    data types until declaration or invocation. LINQ methods are implemented as generic extension
                    methods, making them work seamlessly with collections of any type
                    (<code>IEnumerable&lt;T&gt;</code>).
                </p>
                <pre><code class="language-csharp">// Generic class definition
public class DataStore&lt;T&gt; // T is the type parameter
{
    private List&lt;T&gt; _items = [];

    public void Add(T item) => _items.Add(item);

    public IEnumerable&lt;T&gt; GetAll() => _items;

    // Generic method using LINQ
    public IEnumerable&lt;T&gt; Find(Func&lt;T, bool&gt; predicate)
    {
        return _items.Where(predicate);
    }
}

// Using the generic class with specific types
var stringStore = new DataStore&lt;string&gt;();
stringStore.Add("Apple");
stringStore.Add("Banana");

var intStore = new DataStore&lt;int&gt;();
intStore.Add(10);
intStore.Add(20);

// Using the generic Find method
var longStrings = stringStore.Find(s => s.Length > 5); // T is inferred as string
Console.WriteLine($"Long strings: {string.Join(", ", longStrings)}"); // Output: Long strings: Banana

var largeNumbers = intStore.Find(n => n > 15); // T is inferred as int
Console.WriteLine($"Large numbers: {string.Join(", ", largeNumbers)}"); // Output: Large numbers: 20

// LINQ methods are generic: Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)
// TSource is inferred from the collection type.
</code></pre>

                <h5 class="text-lg font-medium mt-4">Extension Methods</h5>
                <p>
                    Extension methods allow you to "add" methods to existing types (even sealed ones or types you don't
                    own) without modifying their original source code. LINQ is implemented as a set of extension methods
                    on the <code>IEnumerable&lt;T&gt;</code> and <code>IQueryable&lt;T&gt;</code> interfaces, defined in
                    the <code>System.Linq</code> namespace.
                </p>
                <pre><code class="language-csharp">// Define extension methods in a static class
public static class StringExtensions
{
    // 'this string str' indicates it's an extension method for the string type
    public static bool IsNullOrEmpty(this string? str)
    {
        return string.IsNullOrEmpty(str);
    }

    public static string Truncate(this string str, int maxLength)
    {
        if (str == null) return ""; // Handle null input gracefully
        return str.Length <= maxLength ? str : str.Substring(0, maxLength) + "...";
    }
}

// Using the extension methods as if they were part of the string class
string? name = "Alexander the Great";
bool isEmpty = name.IsNullOrEmpty();    // Called like an instance method
string shortened = name.Truncate(10);    // Called like an instance method

Console.WriteLine($"Is '{name}' empty? {isEmpty}"); // Output: Is 'Alexander the Great' empty? False
Console.WriteLine($"Shortened: '{shortened}'"); // Output: Shortened: 'Alexander...'

string? nullString = null;
Console.WriteLine($"Is null empty? {nullString.IsNullOrEmpty()}"); // Output: Is null empty? True

// LINQ methods are extension methods on IEnumerable&lt;T&gt;
using System.Linq; // Namespace containing LINQ extension methods

int[] numbers = [1, 2, 3, 4, 5, 6];
// Where, OrderBy, Select are extension methods called on the 'numbers' array (which implements IEnumerable&lt;int&gt;)
var queryResult = numbers
                    .Where(n => n > 2)
                    .OrderBy(n => n)
                    .Select(n => n * n);

Console.WriteLine($"Query result: {string.Join(", ", queryResult)}"); // Output: Query result: 9, 16, 25, 36
</code></pre>
            </div>

            <div class="section">
                <h3 id="getting-started" class="text-2xl font-semibold">Getting Started with LINQ</h3>

                <p>
                    Language-Integrated Query (LINQ) is a powerful set of features integrated into C# and .NET that
                    provides a consistent, unified way to query and manipulate data, regardless of the data source
                    (e.g., in-memory collections, databases, XML).
                </p>

                <h4 class="text-xl font-medium mt-6">What is LINQ? Integration with C# and .NET</h4>
                <p>
                    LINQ introduces query capabilities directly into the C# language, allowing developers to work with
                    data in a strongly-typed, declarative manner. Key benefits include:
                </p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Unified Querying:</strong> Use the same syntax to query different data sources (LINQ to
                        Objects, LINQ to Entities/SQL, LINQ to XML, etc.).</li>
                    <li><strong>Type Safety:</strong> Queries are checked by the C# compiler, catching errors at compile
                        time rather than runtime.</li>
                    <li><strong>IntelliSense Support:</strong> Get autocompletion and documentation assistance directly
                        in your editor while writing queries.</li>
                    <li><strong>Integration with C#:</strong> Queries are first-class language constructs, not just
                        strings passed to a database. This allows debugging, refactoring, and better maintainability.
                    </li>
                    <li><strong>Declarative Style:</strong> Focus on *what* data you want, not *how* to retrieve it
                        step-by-step.</li>
                </ul>

                <div class="note">
                    <strong>Note:</strong> To use LINQ operators in your C# files, you typically need to add a
                    <code>using System.Linq;</code> directive at the top. This brings the extension methods into scope.
                </div>

                <h4 class="text-xl font-medium mt-6">Query Syntax vs. Method Syntax</h4>
                <p>
                    LINQ provides two equivalent ways to write queries. Both compile down to the same underlying code
                    but offer different stylistic approaches:
                </p>
                <ul class="list-disc pl-4 mb-2">
                    <li><strong>Query Syntax:</strong> A declarative syntax resembling SQL. Often more readable for
                        complex queries involving multiple joins or groupings.</li>
                    <li><strong>Method Syntax (Fluent Syntax):</strong> Uses standard C# method calls (specifically,
                        extension methods) chained together. Provides access to *all* LINQ operators.</li>
                </ul>

                <pre><code class="language-csharp">// Sample data
List&lt;int&gt; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// --- Query Syntax (SQL-like) ---
var evenNumbersQuerySyntax =
    from num in numbers      // Corresponds to FROM
    where num % 2 == 0     // Corresponds to WHERE
    orderby num descending // Corresponds to ORDER BY
    select num * num;      // Corresponds to SELECT

Console.WriteLine("Query Syntax Results (Squared Evens Desc):");
foreach (var n in evenNumbersQuerySyntax) Console.Write($"{n} "); // 100 64 36 16 4
Console.WriteLine("\n");

// --- Method Syntax (Fluent) ---
var evenNumbersMethodSyntax = numbers
    .Where(num => num % 2 == 0)          // Filtering
    .OrderByDescending(num => num)     // Sorting
    .Select(num => num * num);         // Projection

Console.WriteLine("Method Syntax Results (Squared Evens Desc):");
foreach (var n in evenNumbersMethodSyntax) Console.Write($"{n} "); // 100 64 36 16 4
Console.WriteLine("\n");

// Both approaches yield the same result: A sequence containing [100, 64, 36, 16, 4]
</code></pre>

                <h5 class="text-lg font-medium mt-4">Comparing the Syntaxes</h5>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Query Syntax</th>
                            <th>Method Syntax</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Readability</td>
                            <td>Often better for complex queries with multiple clauses (joins, group by, let). Feels
                                familiar to SQL users.</td>
                            <td>Can be more concise for simple operations. Chaining is very clear.</td>
                        </tr>
                        <tr>
                            <td>Available Operators</td>
                            <td>Supports a subset of LINQ operators directly (e.g., `from`, `where`, `select`,
                                `orderby`, `groupby`, `join`, `let`).</td>
                            <td>Supports *all* standard query operators (e.g., `Take`, `Skip`, `Count`, `Sum`, `First`,
                                `Any`, `Distinct`, `Zip`, etc.).</td>
                        </tr>
                        <tr>
                            <td>Flexibility</td>
                            <td>Less flexible; some operators require method syntax calls within or after the query
                                expression.</td>
                            <td>Highly flexible; easy to chain any operator.</td>
                        </tr>
                        <tr>
                            <td>Lambda Expressions</td>
                            <td>Often hides the explicit use of lambda expressions (though they are used implicitly).
                            </td>
                            <td>Explicitly uses lambda expressions for predicates, projections, etc.</td>
                        </tr>
                    </tbody>
                </table>

                <div class="tip">
                    <strong>Tip:</strong> You can mix both syntaxes! A common pattern is to start with query syntax for
                    the main structure and then append method syntax calls for operators not available in query syntax.
                    <pre><code class="language-csharp">var firstFiveExpensiveProducts = (
    from product in ExampleData.GetProducts()
    where product.Price > 100
    orderby product.Price descending
    select product.Name
).Take(5); // Method syntax appended
</code></pre>
                </div>

                <h4 class="text-xl font-medium mt-6">Simple LINQ Queries: Filtering, Sorting, and Projection</h4>
                <p>
                    Let's look at the three fundamental LINQ operations using both syntaxes.
                </p>

                <div class="example-class-definitions">
                    <h5 class="text-lg font-medium">Sample Data for Examples</h5>
                    <pre><code class="language-csharp">List&lt;Person&gt; people = [
    new() { Name = "Alice", Age = 30 },
    new() { Name = "Bob", Age = 25 },
    new() { Name = "Charlie", Age = 35 },
    new() { Name = "David", Age = 17 }
];</code></pre>
                </div>

                <h5 class="text-lg font-medium mt-4">Filtering with `Where`</h5>
                <p>Selects elements based on a condition (predicate).</p>
                <pre><code class="language-csharp">// Query Syntax
var adultsQuery =
    from person in people
    where person.Age >= 18
    select person;

// Method Syntax
var adultsMethod = people.Where(person => person.Age >= 18);

Console.WriteLine("Adults (Query): " + string.Join(", ", adultsQuery.Select(p => p.Name)));
Console.WriteLine("Adults (Method): " + string.Join(", ", adultsMethod.Select(p => p.Name)));
</code></pre>
                <div class="code-result">
                    Adults (Query): Alice, Bob, Charlie
                    Adults (Method): Alice, Bob, Charlie
                </div>

                <h5 class="text-lg font-medium mt-4">Sorting with `OrderBy` / `OrderByDescending`</h5>
                <p>Arranges elements in ascending or descending order based on a key.</p>
                <pre><code class="language-csharp">// Query Syntax (Ascending by Age)
var peopleByAgeQuery =
    from person in people
    orderby person.Age // ascending is default
    select person;

// Method Syntax (Descending by Name)
var peopleByNameDescMethod = people.OrderByDescending(person => person.Name);

Console.WriteLine("Sorted by Age (Query): " + string.Join(", ", peopleByAgeQuery.Select(p => $"{p.Name} ({p.Age})")));
Console.WriteLine("Sorted by Name Desc (Method): " + string.Join(", ", peopleByNameDescMethod.Select(p => p.Name)));
</code></pre>
                <div class="code-result">
                    Sorted by Age (Query): David (17), Bob (25), Alice (30), Charlie (35)
                    Sorted by Name Desc (Method): David, Charlie, Bob, Alice
                </div>

                <h5 class="text-lg font-medium mt-4">Projection with `Select`</h5>
                <p>Transforms each element into a new form (e.g., extracting a property or creating a new object).</p>
                <pre><code class="language-csharp">// Query Syntax - projecting just the names
var namesQuery =
    from person in people
    select person.Name;

// Method Syntax - projecting into an anonymous type
var nameAgePairsMethod = people.Select(person =>
    new { Name = person.Name, YearsOld = person.Age });

Console.WriteLine("Names (Query): " + string.Join(", ", namesQuery));
Console.WriteLine("Name/Age Pairs (Method):");
foreach(var pair in nameAgePairsMethod) {
    Console.WriteLine($"- {pair.Name} is {pair.YearsOld}");
}
</code></pre>
                <div class="code-result">
                    Names (Query): Alice, Bob, Charlie, David
                    Name/Age Pairs (Method):
                    - Alice is 30
                    - Bob is 25
                    - Charlie is 35
                    - David is 17
                </div>

                <h5 class="text-lg font-medium mt-4">Combining Operations</h5>
                <p>LINQ operations are typically chained together to perform complex data manipulation.</p>
                <pre><code class="language-csharp">// Goal: Get the names of adults, sorted alphabetically.

// Query Syntax
var adultNamesSortedQuery =
    from person in people
    where person.Age >= 18
    orderby person.Name
    select person.Name;

// Method Syntax
var adultNamesSortedMethod = people
    .Where(p => p.Age >= 18)
    .OrderBy(p => p.Name)
    .Select(p => p.Name);

Console.WriteLine("Sorted Adult Names (Query): " + string.Join(", ", adultNamesSortedQuery));
Console.WriteLine("Sorted Adult Names (Method): " + string.Join(", ", adultNamesSortedMethod));
</code></pre>
                <div class="code-result">
                    Sorted Adult Names (Query): Alice, Bob, Charlie
                    Sorted Adult Names (Method): Alice, Bob, Charlie
                </div>
                <p>
                    These fundamental operations form the building blocks for almost all LINQ queries. Understanding
                    them well is key to mastering LINQ.
                </p>
            </div>
        </div>

        <!-- Part 2: LINQ Fundamentals -->
        <div class="chapter">
            <h2 class="text-3xl font-bold">Part 2: LINQ Fundamentals</h2>

            <div class="section">
                <h3 id="query-syntax" class="text-2xl font-semibold">Query Syntax Deep Dive</h3>

                <p>
                    The query syntax provides a declarative, SQL-like way to express LINQ queries. While method syntax
                    offers more operators, query syntax can be more readable for certain types of queries, especially
                    those involving joins, groupings, or multiple range variables.
                </p>

                <h4 class="text-xl font-medium mt-6">The `from`, `where`, `select` Clauses</h4>
                <p>
                    These are the most fundamental clauses in query syntax. A query expression *must* start with a
                    <code>from</code> clause and *typically* ends with a <code>select</code> or <code>group</code>
                    clause.
                </p>
                <div class="example-class-definitions">
                    <h5 class="text-lg font-medium">Sample Data for Examples</h5>
                    <pre><code class="language-csharp">List&lt;Product&gt; products = [
    new() { Id = 1, Name = "Laptop", Price = 1200.00m, Category = "Electronics" },
    new() { Id = 2, Name = "Desk Chair", Price = 250.50m, Category = "Furniture" },
    new() { Id = 3, Name = "Smartphone", Price = 800.00m, Category = "Electronics" },
    new() { Id = 4, Name = "Bookshelf", Price = 175.00m, Category = "Furniture" },
    new() { Id = 5, Name = "Keyboard", Price = 75.00m, Category = "Electronics", InStock = false }
];</code></pre>
                </div>
                <pre><code class="language-csharp">// Basic structure
var electronicProductNames =
    from product in products                // 1. Define the data source and range variable (product)
    where product.Category == "Electronics" // 2. Filter based on a condition
    select product.Name;                    // 3. Project the result

Console.WriteLine("Electronic Products: " + string.Join(", ", electronicProductNames));
</code></pre>
                <div class="code-result">
                    Electronic Products: Laptop, Smartphone, Keyboard
                </div>

                <h5 class="text-lg font-medium mt-4">Multiple `from` Clauses (SelectMany)</h5>
                <p>Using multiple <code>from</code> clauses allows you to query nested collections or perform cross
                    joins.</p>
                <pre><code class="language-csharp">List&lt;Customer&gt; customers = [
    new() { Name = "Alice", OrderList = [new Order { Id = 101, Total = 50 }, new Order { Id = 102, Total = 150 }] },
    new() { Name = "Bob", OrderList = [new Order { Id = 201, Total = 200 }] }
];

// Get all orders from all customers
var allOrders =
    from customer in customers // Outer loop
    from order in customer.OrderList // Inner loop (flattens the nested collection)
    where order.Total > 100
    select new { customer.Name, order.Id, order.Total };

Console.WriteLine("High Value Orders:");
foreach(var item in allOrders)
{
    Console.WriteLine($"- {item.Name}: Order {item.Id}, Total ${item.Total}");
}
</code></pre>
                <div class="code-result">
                    High Value Orders:
                    - Alice: Order 102, Total $150
                    - Bob: Order 201, Total $200
                </div>
                <p>This is equivalent to using the <code>SelectMany</code> method in method syntax.</p>

                <h5 class="text-lg font-medium mt-4">Multiple `where` Clauses</h5>
                <p>Multiple <code>where</code> clauses act like a logical AND operation.</p>
                <pre><code class="language-csharp">// Find expensive electronics
var expensiveElectronics =
    from product in products
    where product.Category == "Electronics" // First filter
    where product.Price > 500               // Second filter (applied to results of first)
    select product.Name;

// Equivalent using &&
var expensiveElectronicsAlt =
    from product in products
    where product.Category == "Electronics" && product.Price > 500
    select product.Name;

Console.WriteLine("Expensive Electronics: " + string.Join(", ", expensiveElectronics));
</code></pre>
                <div class="code-result">
                    Expensive Electronics: Laptop, Smartphone
                </div>

                <h4 class="text-xl font-medium mt-6">Ordering with `orderby`</h4>
                <p>The <code>orderby</code> clause sorts the sequence. You can sort by multiple keys and specify
                    ascending (default) or descending order.</p>
                <pre><code class="language-csharp">var sortedProducts =
    from product in products
    orderby product.Category ascending, product.Price descending // Sort first by category, then by price within category
    select $"{product.Name} ({product.Category}, ${product.Price})";

Console.WriteLine("Sorted Products:");
foreach(var p in sortedProducts) {
    Console.WriteLine($"- {p}");
}
</code></pre>
                <div class="code-result">
                    Sorted Products:
                    - Laptop (Electronics, $1200.00)
                    - Smartphone (Electronics, $800.00)
                    - Keyboard (Electronics, $75.00)
                    - Desk Chair (Furniture, $250.50)
                    - Bookshelf (Furniture, $175.00)
                </div>

                <h4 class="text-xl font-medium mt-6">Joining Collections with `join`</h4>
                <p>The <code>join</code> clause performs an inner join between two sequences based on matching keys.</p>
                <div class="example-class-definitions">
                    <h5 class="text-lg font-medium">Sample Data for Join Example</h5>
                    <pre><code class="language-csharp">List&lt;Category&gt; categories = [
    new() { Id = 1, Name = "Electronics" },
    new() { Id = 2, Name = "Furniture" },
    new() { Id = 3, Name = "Apparel" } // Category with no matching products
];

List&lt;Product&gt; productsForJoin = [
    new() { Id = 101, Name = "Laptop", Category = "Electronics" },
    new() { Id = 102, Name = "Desk", Category = "Furniture" },
    new() { Id = 103, Name = "Monitor", Category = "Electronics" }
];</code></pre>
                </div>
                <pre><code class="language-csharp">// Inner Join: Combine products with their category names
var productDetails =
    from product in productsForJoin
    join category in categories
        on product.Category equals category.Name // Join condition
    select new { product.Name, CategoryName = category.Name }; // Project the result

Console.WriteLine("Product Details (Inner Join):");
foreach(var item in productDetails) {
    Console.WriteLine($"- {item.Name}, Category: {item.CategoryName}");
}

// Group Join (for Left Outer Join simulation)
var categoryProductGroups =
    from category in categories
    join product in productsForJoin
        on category.Name equals product.Category
        into productGroup // 'into' creates a temporary group
    select new {
        CategoryName = category.Name,
        Products = productGroup // Contains matching products for this category
    };

Console.WriteLine("\nProducts by Category (Group Join):");
foreach (var group in categoryProductGroups) {
    Console.WriteLine($"- Category: {group.CategoryName}");
    foreach (var product in group.Products) {
        Console.WriteLine($"  * {product.Name}");
    }
    if (!group.Products.Any()) {
        Console.WriteLine("  (No products in this category)");
    }
}

// Left Outer Join (using group join and DefaultIfEmpty)
var leftOuterJoin =
    from category in categories
    join product in productsForJoin
        on category.Name equals product.Category
        into productGroup
    from productOrNull in productGroup.DefaultIfEmpty() // Get product or null if no match
    select new {
        CategoryName = category.Name,
        ProductName = productOrNull?.Name ?? "(No Product)" // Use null-conditional operator
    };

Console.WriteLine("\nCategory Product List (Left Outer Join):");
foreach(var item in leftOuterJoin) {
    Console.WriteLine($"- Category: {item.CategoryName}, Product: {item.ProductName}");
}
</code></pre>
                <div class="code-result">
                    Product Details (Inner Join):
                    - Laptop, Category: Electronics
                    - Desk, Category: Furniture
                    - Monitor, Category: Electronics

                    Products by Category (Group Join):
                    - Category: Electronics
                    * Laptop
                    * Monitor
                    - Category: Furniture
                    * Desk
                    - Category: Apparel
                    (No products in this category)

                    Category Product List (Left Outer Join):
                    - Category: Electronics, Product: Laptop
                    - Category: Electronics, Product: Monitor
                    - Category: Furniture, Product: Desk
                    - Category: Apparel, Product: (No Product)
                </div>

                <h4 class="text-xl font-medium mt-6">Grouping with `group by`</h4>
                <p>The <code>group by</code> clause groups elements based on a key. The result is a sequence of groups
                    (<code>IGrouping&lt;TKey, TElement&gt;</code>).</p>
                <pre><code class="language-csharp">// Group products by category
var productsByCategory =
    from product in products
    group product by product.Category; // Group by the Category property

Console.WriteLine("Products Grouped by Category:");
foreach (var categoryGroup in productsByCategory)
{
    Console.WriteLine($"--- Category: {categoryGroup.Key} ---"); // Key is the category name
    foreach (var product in categoryGroup) // Iterate through products in the group
    {
        Console.WriteLine($"  - {product.Name} (${product.Price})");
    }
}

// Grouping and projecting into a new type with aggregate data
var categoryStats =
    from product in products
    group product by product.Category into categoryGroup // 'into' names the group
    select new {
        Category = categoryGroup.Key,
        Count = categoryGroup.Count(),
        AveragePrice = categoryGroup.Average(p => p.Price),
        TotalPrice = categoryGroup.Sum(p => p.Price)
    };

Console.WriteLine("\nCategory Statistics:");
foreach(var stat in categoryStats) {
    Console.WriteLine($"- {stat.Category}: Count={stat.Count}, Avg Price=${stat.AveragePrice:F2}, Total=${stat.TotalPrice:F2}");
}
</code></pre>
                <div class="code-result">
                    Products Grouped by Category:
                    --- Category: Electronics ---
                    - Laptop ($1200.00)
                    - Smartphone ($800.00)
                    - Keyboard ($75.00)
                    --- Category: Furniture ---
                    - Desk Chair ($250.50)
                    - Bookshelf ($175.00)

                    Category Statistics:
                    - Electronics: Count=3, Avg Price=$691.67, Total=$2075.00
                    - Furniture: Count=2, Avg Price=$212.75, Total=$425.50
                </div>

                <h4 class="text-xl font-medium mt-6">Intermediate Variables with `let`</h4>
                <p>The <code>let</code> clause introduces a new range variable within the query, often used to store the
                    result of a sub-expression to avoid recalculation or improve readability.</p>
                <pre><code class="language-csharp">// Calculate discounted price and filter based on it
var discountedHighValueProducts =
    from product in products
    let discount = product.Price > 500 ? 0.10m : 0.05m // Calculate discount rate
    let discountedPrice = product.Price * (1 - discount) // Calculate final price
    where discountedPrice > 100                         // Filter using the calculated price
    orderby discountedPrice descending
    select new {
        product.Name,
        OriginalPrice = product.Price,
        DiscountedPrice = discountedPrice
    };

Console.WriteLine("Discounted High Value Products:");
foreach(var p in discountedHighValueProducts) {
    Console.WriteLine($"- {p.Name}: Original ${p.OriginalPrice:F2}, Discounted ${p.DiscountedPrice:F2}");
}
</code></pre>
                <div class="code-result">
                    Discounted High Value Products:
                    - Laptop: Original $1200.00, Discounted $1080.00
                    - Smartphone: Original $800.00, Discounted $720.00
                    - Desk Chair: Original $250.50, Discounted $237.98
                    - Bookshelf: Original $175.00, Discounted $166.25
                </div>

                <div class="warning">
                    <strong>Important:</strong> Query syntax is essentially syntactic sugar. The compiler translates
                    query expressions into method calls. Not all LINQ operators have a dedicated query syntax keyword
                    (e.g., `Take`, `Skip`, `Any`, `All`, `Sum`, `Count`). For these, you'll need to use method syntax,
                    either by calling methods on the final result of a query expression or by mixing syntax.
                </div>
            </div>

            <div class="section">
                <h3 id="method-syntax" class="text-2xl font-semibold">Method Syntax and Standard Query Operators</h3>

                <p>
                    Method syntax (or fluent syntax) uses chained extension method calls to build LINQ queries. It
                    provides access to the complete set of Standard Query Operators (SQOs) defined in the
                    <code>System.Linq.Enumerable</code> and <code>System.Linq.Queryable</code> classes.
                </p>

                <h4 class="text-xl font-medium mt-6">Core Operators: `Where`, `Select`, `OrderBy`, Aggregates</h4>
                <div class="example-class-definitions">
                    <h5 class="text-lg font-medium">Sample Data for Examples</h5>
                    <pre><code class="language-csharp">List&lt;Employee&gt; employees = [
    new() { Id = 1, Name = "Alice", Department = "HR", Salary = 60000 },
    new() { Id = 2, Name = "Bob", Department = "IT", Salary = 75000 },
    new() { Id = 3, Name = "Charlie", Department = "Finance", Salary = 65000 },
    new() { Id = 4, Name = "David", Department = "IT", Salary = 80000 },
    new() { Id = 5, Name = "Eve", Department = "HR", Salary = 55000 }
];</code></pre>
                </div>

                <h5 class="text-lg font-medium mt-4">Filtering with `Where`</h5>
                <p>Selects elements based on a predicate (a function returning bool).</p>
                <pre><code class="language-csharp">// Find employees in the IT department
var itEmployees = employees.Where(emp => emp.Department == "IT");
Console.WriteLine("IT Employees: " + string.Join(", ", itEmployees.Select(e => e.Name)));

// Find high-earning employees (Salary > 70000)
var highEarners = employees.Where(e => e.Salary > 70000);
Console.WriteLine("High Earners: " + string.Join(", ", highEarners.Select(e => e.Name)));

// Using the overload with index
var employeesAtEvenIndex = employees.Where((emp, index) => index % 2 == 0);
Console.WriteLine("Employees at even indices: " + string.Join(", ", employeesAtEvenIndex.Select(e => e.Name)));
</code></pre>
                <div class="code-result">
                    IT Employees: Bob, David
                    High Earners: Bob, David
                    Employees at even indices: Alice, Charlie, Eve
                </div>

                <h5 class="text-lg font-medium mt-4">Projection with `Select`</h5>
                <p>Transforms each element into a new form.</p>
                <pre><code class="language-csharp">// Get only the names of employees
var employeeNames = employees.Select(emp => emp.Name);
Console.WriteLine("Employee Names: " + string.Join(", ", employeeNames));

// Create anonymous objects with specific properties
var employeeSummaries = employees.Select(emp => new {
    Identifier = emp.Id,
    EmployeeName = emp.Name,
    AnnualSalary = emp.Salary
});

Console.WriteLine("Employee Summaries:");
foreach(var summary in employeeSummaries) {
    Console.WriteLine($"- ID: {summary.Identifier}, Name: {summary.EmployeeName}, Salary: ${summary.AnnualSalary}");
}

// Using the overload with index
var indexedNames = employees.Select((emp, index) => $"{index + 1}. {emp.Name}");
Console.WriteLine("Indexed Names: " + string.Join("; ", indexedNames));
</code></pre>
                <div class="code-result">
                    Employee Names: Alice, Bob, Charlie, David, Eve
                    Employee Summaries:
                    - ID: 1, Name: Alice, Salary: $60000
                    - ID: 2, Name: Bob, Salary: $75000
                    - ID: 3, Name: Charlie, Salary: $65000
                    - ID: 4, Name: David, Salary: $80000
                    - ID: 5, Name: Eve, Salary: $55000
                    Indexed Names: 1. Alice; 2. Bob; 3. Charlie; 4. David; 5. Eve
                </div>

                <h5 class="text-lg font-medium mt-4">Sorting with `OrderBy`, `OrderByDescending`, `ThenBy`,
                    `ThenByDescending`</h5>
                <p>Sorts the sequence based on one or more keys.</p>
                <pre><code class="language-csharp">// Sort by salary ascending
var sortedBySalaryAsc = employees.OrderBy(e => e.Salary);
Console.WriteLine("Sorted by Salary (Asc): " + string.Join(", ", sortedBySalaryAsc.Select(e => $"{e.Name} (${e.Salary})")));

// Sort by department ascending, then by salary descending within each department
var sortedByDeptThenSalaryDesc = employees
    .OrderBy(e => e.Department)        // Primary sort key (ascending)
    .ThenByDescending(e => e.Salary); // Secondary sort key (descending)

Console.WriteLine("Sorted by Dept (Asc), then Salary (Desc):");
foreach(var e in sortedByDeptThenSalaryDesc) {
    Console.WriteLine($"- {e.Department}: {e.Name} (${e.Salary})");
}
</code></pre>
                <div class="code-result">
                    Sorted by Salary (Asc): Eve ($55000), Alice ($60000), Charlie ($65000), Bob ($75000), David ($80000)
                    Sorted by Dept (Asc), then Salary (Desc):
                    - Finance: Charlie ($65000)
                    - HR: Alice ($60000)
                    - HR: Eve ($55000)
                    - IT: David ($80000)
                    - IT: Bob ($75000)
                </div>

                <h5 class="text-lg font-medium mt-4">Aggregate Functions</h5>
                <p>These operators compute a single scalar value from the sequence. They cause *immediate execution*.
                </p>
                <pre><code class="language-csharp">// Count elements
int totalEmployees = employees.Count();
int hrEmployeesCount = employees.Count(e => e.Department == "HR");
Console.WriteLine($"Total Employees: {totalEmployees}, HR Employees: {hrEmployeesCount}");

// Sum values
decimal totalSalaryPayout = employees.Sum(e => e.Salary);
Console.WriteLine($"Total Salary Payout: ${totalSalaryPayout:F2}");

// Average values
double averageSalary = employees.Average(e => (double)e.Salary); // Cast to double for Average
Console.WriteLine($"Average Salary: ${averageSalary:F2}");

// Min/Max values
decimal lowestSalary = employees.Min(e => e.Salary);
decimal highestSalary = employees.Max(e => e.Salary);
Console.WriteLine($"Salary Range: ${lowestSalary:F2} - ${highestSalary:F2}");

// Aggregate for custom accumulations
// Example: Create a comma-separated list of names
string nameList = employees.Aggregate(
    seed: "", // Starting value
    func: (currentList, employee) => currentList == "" ? employee.Name : currentList + ", " + employee.Name,
    resultSelector: finalResult => $"Employees: {finalResult}" // Optional final transformation
);
Console.WriteLine(nameList);

// Simpler way for name list using string.Join
string nameListSimple = "Employees: " + string.Join(", ", employees.Select(e => e.Name));
Console.WriteLine(nameListSimple);
</code></pre>
                <div class="code-result">
                    Total Employees: 5, HR Employees: 2
                    Total Salary Payout: $335000.00
                    Average Salary: $67000.00
                    Salary Range: $55000.00 - $80000.00
                    Employees: Alice, Bob, Charlie, David, Eve
                    Employees: Alice, Bob, Charlie, David, Eve
                </div>

                <h4 class="text-xl font-medium mt-6">Chaining Methods for Complex Queries</h4>
                <p>Method syntax shines when composing complex queries by chaining multiple operators together fluently.
                </p>
                <pre><code class="language-csharp">// Goal: Get the names and departments of the top 2 highest-paid IT employees.
var topItEarnersInfo = employees
    .Where(e => e.Department == "IT")       // Filter: Only IT department
    .OrderByDescending(e => e.Salary)   // Sort: Highest salary first
    .Take(2)                             // Select: Top 2 results
    .Select(e => new { e.Name, e.Department, e.Salary }) // Project: Name and Department
    .ToList();                           // Execute: Materialize results into a list

Console.WriteLine("Top 2 IT Earners:");
foreach(var info in topItEarnersInfo) {
    Console.WriteLine($"- Name: {info.Name}, Dept: {info.Department}, Salary: ${info.Salary}");
}
</code></pre>
                <div class="code-result">
                    Top 2 IT Earners:
                    - Name: David, Dept: IT, Salary: $80000
                    - Name: Bob, Dept: IT, Salary: $75000
                </div>

                <h4 class="text-xl font-medium mt-6">Common Method Chains and Other Useful Operators</h4>

                <h5 class="text-lg font-medium mt-4">Element Operators</h5>
                <p>Retrieve a specific element from a sequence. Most have `OrDefault` versions that return the default
                    value (e.g., null for reference types) instead of throwing an exception if the element isn't found.
                </p>
                <pre><code class="language-csharp">List&lt;int&gt; numbers = [10, 20, 30, 40, 50];
List&lt;int&gt; emptyList = [];

// First / FirstOrDefault
int first = numbers.First(); // 10
int firstOrDefault = emptyList.FirstOrDefault(); // 0 (default for int)
int firstMatching = numbers.First(n => n > 25); // 30
// int firstNoMatch = numbers.First(n => n > 100); // Throws InvalidOperationException

// Last / LastOrDefault
int last = numbers.Last(); // 50
int lastOrDefault = emptyList.LastOrDefault(); // 0
int lastMatching = numbers.Last(n => n < 35); // 30

// Single / SingleOrDefault (Expect exactly one match)
// int singleNoMatch = numbers.Single(n => n > 100); // Throws InvalidOperationException
// int singleMultipleMatch = numbers.Single(n => n > 10); // Throws InvalidOperationException
int singleMatch = numbers.Single(n => n == 30); // 30
Employee charlie = employees.SingleOrDefault(e => e.Name == "Charlie"); // Finds Charlie
Employee nonExistent = employees.SingleOrDefault(e => e.Name == "Zoe"); // Returns null

// ElementAt / ElementAtOrDefault (By index)
int elementAt2 = numbers.ElementAt(2); // 30 (0-based index)
int elementAtOrDefault = numbers.ElementAtOrDefault(10); // 0 (index out of bounds)
</code></pre>

                <h5 class="text-lg font-medium mt-4">Quantifiers</h5>
                <p>Return a boolean value indicating whether some or all elements satisfy a condition.</p>
                <pre><code class="language-csharp">List&lt;int&gt; scores = [75, 88, 92, 60, 99];

// Any: Checks if at least one element satisfies the condition
bool anyFailed = scores.Any(s => s < 65); // true (60)
bool anyPerfect = scores.Any(s => s == 100); // false

// All: Checks if all elements satisfy the condition
bool allPassed = scores.All(s => s >= 65); // true
bool allExcellent = scores.All(s => s >= 90); // false

// Contains: Checks if the sequence contains a specific element (uses default equality comparer)
bool contains92 = scores.Contains(92); // true
bool contains50 = scores.Contains(50); // false
</code></pre>

                <h5 class="text-lg font-medium mt-4">Set Operators</h5>
                <p>Perform set operations like union, intersection, and difference.</p>
                <pre><code class="language-csharp">List&lt;int&gt; set1 = [1, 2, 3, 4, 5];
List&lt;int&gt; set2 = [4, 5, 6, 7, 8];

// Distinct: Removes duplicates from a single sequence
List&lt;int&gt; duplicates = [1, 2, 2, 3, 3, 3, 4];
var distinctNumbers = duplicates.Distinct(); // [1, 2, 3, 4]

// Union: Combines two sequences, removing duplicates
var unionResult = set1.Union(set2); // [1, 2, 3, 4, 5, 6, 7, 8]

// Intersect: Returns elements common to both sequences
var intersectResult = set1.Intersect(set2); // [4, 5]

// Except: Returns elements from the first sequence not present in the second
var exceptResult = set1.Except(set2); // [1, 2, 3]

// Concat: Concatenates two sequences, preserving duplicates and order
var concatResult = set1.Concat(set2); // [1, 2, 3, 4, 5, 4, 5, 6, 7, 8]
</code></pre>

                <h5 class="text-lg font-medium mt-4">Partitioning Operators</h5>
                <p>Select a contiguous subset of elements from a sequence.</p>
                <pre><code class="language-csharp">List&lt;string&gt; items = ["A", "B", "C", "D", "E", "F", "G"];

// Take: Returns the first N elements
var firstThree = items.Take(3); // ["A", "B", "C"]

// Skip: Skips the first N elements and returns the rest
var skipTwo = items.Skip(2); // ["C", "D", "E", "F", "G"]

// TakeWhile: Returns elements from the start as long as a condition is true
var takeWhileLessThanD = items.TakeWhile(item => item.CompareTo("D") < 0); // ["A", "B", "C"]

// SkipWhile: Skips elements from the start as long as a condition is true
var skipWhileLessThanC = items.SkipWhile(item => item.CompareTo("C") < 0); // ["C", "D", "E", "F", "G"]

// Chunk (.NET 6+): Splits the sequence into chunks of a specified size
var chunksOfThree = items.Chunk(3);
// Result is IEnumerable&lt;string[]&gt;: [ ["A", "B", "C"], ["D", "E", "F"], ["G"] ]
</code></pre>

                <div class="tip">
                    <strong>Tip:</strong> Method syntax is generally preferred by many C# developers due to its
                    consistency, access to all operators, and better composability, especially when dealing with complex
                    types or needing intermediate steps. However, choose the syntax that enhances the readability of
                    your specific query.
                </div>
            </div>

            <div class="section">
                <h3 id="deferred-execution" class="text-2xl font-semibold">Deferred Execution and Performance</h3>

                <p>
                    One of the most fundamental and often misunderstood concepts in LINQ is <strong>deferred
                        execution</strong> (also known as lazy evaluation). Most LINQ queries are *not* executed when
                    they are defined, but only when their results are actually enumerated.
                </p>

                <h4 class="text-xl font-medium mt-6">Understanding Lazy Evaluation</h4>
                <p>
                    When you write a LINQ query, you are essentially building a recipe or plan for retrieving and
                    transforming data. The actual work of fetching and processing the data is deferred until you iterate
                    over the query results (e.g., using a <code>foreach</code> loop) or call a method that forces
                    immediate execution (like <code>ToList()</code>, <code>Count()</code>, <code>First()</code>).
                </p>
                <pre><code class="language-csharp">// Sample data
List&lt;int&gt; numbers = [1, 2, 3, 4, 5];
Console.WriteLine($"Initial list: {string.Join(", ", numbers)}");

// 1. Define the query - NO execution happens here.
//    'query' holds the *definition* of the operation.
Console.WriteLine("Defining the query...");
var query = numbers.Where(n => {
    Console.WriteLine($"Filtering {n}"); // Side effect to show execution
    return n % 2 == 0;
});

Console.WriteLine("Query defined. Now modifying the source collection...");
// 2. Modify the source collection *after* defining the query.
numbers.Add(6);
numbers.Add(8);
Console.WriteLine($"List after modification: {string.Join(", ", numbers)}");

Console.WriteLine("Executing the query via foreach loop...");
// 3. Execute the query by iterating - NOW the lambda runs.
foreach (var number in query)
{
    Console.WriteLine($"Yielded {number}");
}

Console.WriteLine("\nExecuting the query again...");
// 4. Execute again - the filtering process runs again!
foreach (var number in query)
{
    Console.WriteLine($"Yielded {number} (second time)");
}
</code></pre>
                <div class="code-result">
                    Initial list: 1, 2, 3, 4, 5
                    Defining the query...
                    Query defined. Now modifying the source collection...
                    List after modification: 1, 2, 3, 4, 5, 6, 8
                    Executing the query via foreach loop...
                    Filtering 1
                    Filtering 2
                    Yielded 2
                    Filtering 3
                    Filtering 4
                    Yielded 4
                    Filtering 5
                    Filtering 6
                    Yielded 6
                    Filtering 8
                    Yielded 8

                    Executing the query again...
                    Filtering 1
                    Filtering 2
                    Yielded 2 (second time)
                    Filtering 3
                    Filtering 4
                    Yielded 4 (second time)
                    Filtering 5
                    Filtering 6
                    Yielded 6 (second time)
                    Filtering 8
                    Yielded 8 (second time)
                </div>

                <h5 class="text-lg font-medium mt-4">Key Implications of Deferred Execution</h5>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Always Fresh Data:</strong> Queries execute against the *current* state of the data
                        source each time they are enumerated.</li>
                    <li><strong>Efficiency (Potential):</strong> If you only need the first few items (e.g., using
                        <code>Take(5)</code>), the entire source might not be processed.
                    </li>
                    <li><strong>Composability:</strong> Queries can be built up in stages without intermediate memory
                        allocations.</li>
                    <li><strong>Potential for Multiple Enumerations:</strong> If you enumerate the same query variable
                        multiple times, the underlying operations are performed multiple times (as seen above), which
                        can be inefficient.</li>
                </ul>

                <h4 class="text-xl font-medium mt-6">Immediate Execution: Forcing Query Evaluation</h4>
                <p>
                    Some LINQ operators force immediate execution because they need to produce a single value or a
                    concrete collection. When you call these methods, the query is executed right away.
                </p>
                <h5 class="text-lg font-medium mt-4">Operators Causing Immediate Execution</h5>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Conversion Operators:</strong> <code>ToList()</code>, <code>ToArray()</code>,
                        <code>ToDictionary()</code>, <code>ToHashSet()</code>, <code>ToLookup()</code>. These create a
                        snapshot of the query results in a specific collection type.
                    </li>
                    <li><strong>Element Operators:</strong> <code>First()</code>, <code>FirstOrDefault()</code>,
                        <code>Last()</code>, <code>LastOrDefault()</code>, <code>Single()</code>,
                        <code>SingleOrDefault()</code>, <code>ElementAt()</code>, <code>ElementAtOrDefault()</code>.
                        These need to find and return a specific element.
                    </li>
                    <li><strong>Aggregate Operators:</strong> <code>Count()</code>, <code>LongCount()</code>,
                        <code>Sum()</code>, <code>Average()</code>, <code>Min()</code>, <code>Max()</code>,
                        <code>Aggregate()</code>. These need to iterate through the sequence to calculate a result.
                    </li>
                </ul>

                <pre><code class="language-csharp">List&lt;int&gt; numbers = [1, 2, 3, 4, 5, 6];
Console.WriteLine("Original numbers: " + string.Join(", ", numbers));

// Define a query
var query = numbers.Where(n => n % 2 == 0);
Console.WriteLine("Query defined.");

// Force execution with ToList()
Console.WriteLine("Calling ToList()...");
List&lt;int&gt; evenNumbersList = query.ToList(); // Execution happens here!
Console.WriteLine("Execution complete via ToList().");
Console.WriteLine("Resulting list: " + string.Join(", ", evenNumbersList));

// Modify the original list AFTER ToList()
numbers.Add(8);
Console.WriteLine("Original list modified: " + string.Join(", ", numbers));

// The list created by ToList() is a snapshot - it doesn't change
Console.WriteLine("Snapshot list (unchanged): " + string.Join(", ", evenNumbersList));

// Force execution with Count()
Console.WriteLine("Calling Count()...");
int count = query.Count(); // Execution happens here! Uses the *modified* numbers list.
Console.WriteLine("Execution complete via Count().");
Console.WriteLine($"Count of even numbers now: {count}");
</code></pre>
                <div class="code-result">
                    Original numbers: 1, 2, 3, 4, 5, 6
                    Query defined.
                    Calling ToList()...
                    Execution complete via ToList().
                    Resulting list: 2, 4, 6
                    Original list modified: 1, 2, 3, 4, 5, 6, 8
                    Snapshot list (unchanged): 2, 4, 6
                    Calling Count()...
                    Execution complete via Count().
                    Count of even numbers now: 4
                </div>

                <h4 class="text-xl font-medium mt-6">When to Materialize Results (`ToList()`, `ToArray()`)</h4>
                <p>
                    While deferred execution is powerful, there are times when you *should* force immediate execution
                    and store the results in a collection (materialize the query):
                </p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Prevent Multiple Enumerations:</strong> If you need to use the results of an expensive
                        query multiple times (e.g., get the count, then iterate, then get the sum), materialize it once
                        into a list or array and work with that collection.</li>
                    <li><strong>Capture a Snapshot:</strong> If the underlying data source might change between the
                        query definition and its use, and you need the results based on the state at a specific point in
                        time.</li>
                    <li><strong>Pass Results to Methods Expecting Concrete Collections:</strong> Some methods require
                        <code>List&lt;T&gt;</code> or <code>T[]</code>, not just <code>IEnumerable&lt;T&gt;</code>.
                    </li>
                    <li><strong>Improve Performance for Certain Operations:</strong> Sometimes, filtering a large
                        dataset down and materializing the smaller result set before further complex processing can be
                        faster.</li>
                    <li><strong>Database Queries (LINQ to SQL/Entities):</strong> To prevent multiple round trips to the
                        database. Execute the query once with <code>ToList()</code>/<code>ToArray()</code> and work with
                        the in-memory results.</li>
                </ul>

                <pre><code class="language-csharp">// Example: Avoiding multiple enumeration of an expensive query
IEnumerable&lt;Product&gt; GetExpensiveProductsFromDb()
{
    Console.WriteLine("--- Querying database for expensive products ---");
    // Simulate a database call
    using var context = new ECommerceContext();
    // Seed some data for the example
    if (!context.Products.Any()) {
        context.Products.AddRange(ExampleData.GetProducts());
        context.SaveChanges();
    }
    return context.Products.Where(p => p.Price > 100).AsEnumerable(); // Use AsEnumerable to show deferred behavior more clearly
}

// Inefficient: Database queried multiple times
var expensiveQuery = GetExpensiveProductsFromDb();

Console.WriteLine("Getting count (Execution 1)...");
int count1 = expensiveQuery.Count();
Console.WriteLine($"Count: {count1}");

Console.WriteLine("Iterating (Execution 2)...");
foreach (var p in expensiveQuery) { Console.WriteLine($"- {p.Name}"); }

Console.WriteLine("Getting max price (Execution 3)...");
decimal maxPrice1 = expensiveQuery.Max(p => p.Price);
Console.WriteLine($"Max Price: {maxPrice1}");

Console.WriteLine("\n--- Efficient approach ---");

// Efficient: Materialize once
Console.WriteLine("Materializing query (Execution 1)...");
List&lt;Product&gt; expensiveList = GetExpensiveProductsFromDb().ToList();

Console.WriteLine("Getting count (from list)...");
int count2 = expensiveList.Count; // Uses the list, no re-execution
Console.WriteLine($"Count: {count2}");

Console.WriteLine("Iterating (from list)...");
foreach (var p in expensiveList) { Console.WriteLine($"- {p.Name}"); } // Uses the list

Console.WriteLine("Getting max price (from list)...");
decimal maxPrice2 = expensiveList.Max(p => p.Price); // Uses the list
Console.WriteLine($"Max Price: {maxPrice2}");
</code></pre>
                <div class="code-result">
                    Getting count (Execution 1)...
                    --- Querying database for expensive products ---
                    Count: 3 <!-- Assuming Laptop, Desk Chair, Bookshelf are > 100 -->
                    Iterating (Execution 2)...
                    --- Querying database for expensive products ---
                    - Laptop
                    - Desk Chair
                    - Bookshelf
                    Getting max price (Execution 3)...
                    --- Querying database for expensive products ---
                    Max Price: 1200.00

                    --- Efficient approach ---
                    Materializing query (Execution 1)...
                    --- Querying database for expensive products ---
                    Getting count (from list)...
                    Count: 3
                    Iterating (from list)...
                    - Laptop
                    - Desk Chair
                    - Bookshelf
                    Getting max price (from list)...
                    Max Price: 1200.00
                </div>

                <div class="warning">
                    <strong>Performance Trap:</strong> Be mindful of repeatedly enumerating
                    <code>IQueryable&lt;T&gt;</code> results from databases without materializing. Each enumeration
                    often triggers a separate database query, which can severely impact performance (the N+1 problem is
                    a common example). Use <code>ToList()</code>, <code>ToArray()</code>, etc., after defining your
                    database query if you need to access the results multiple times.
                </div>
            </div>
        </div>

        <!-- Part 3: Intermediate LINQ Techniques -->
        <div class="chapter">
            <h2 class="text-3xl font-bold">Part 3: Intermediate LINQ Techniques</h2>

            <div class="section">
                <h3 id="advanced-operators" class="text-2xl font-semibold">Advanced Query Operators</h3>

                <p>
                    Beyond the basics of filtering, sorting, and projecting, LINQ offers a rich set of operators for
                    more complex data manipulation tasks like advanced grouping, set operations, partitioning, joining,
                    and element retrieval.
                </p>

                <h4 class="text-xl font-medium mt-6">Grouping (`GroupBy`) Deep Dive</h4>
                <p>
                    We saw basic grouping earlier. <code>GroupBy</code> is very powerful and has several overloads
                    allowing customization of the key, the elements within the group, and the final result projection.
                </p>
                <div class="example-class-definitions">
                    <h5 class="text-lg font-medium">Sample Data for GroupBy Examples</h5>
                    <pre><code class="language-csharp">List&lt;Sale&gt; sales = [
    new() { ProductId = 1, Category = "Electronics", Region = "North", Amount = 1000 },
    new() { ProductId = 2, Category = "Furniture", Region = "South", Amount = 750 },
    new() { ProductId = 3, Category = "Electronics", Region = "North", Amount = 500 },
    new() { ProductId = 4, Category = "Clothing", Region = "East", Amount = 250 },
    new() { ProductId = 5, Category = "Electronics", Region = "South", Amount = 800 },
    new() { ProductId = 6, Category = "Furniture", Region = "North", Amount = 1200 },
    new() { ProductId = 7, Category = "Clothing", Region = "West", Amount = 300 }
];</code></pre>
                </div>

                <h5 class="text-lg font-medium mt-4">Grouping by Composite Key</h5>
                <p>Use an anonymous type to group by multiple properties.</p>
                <pre><code class="language-csharp">// Group sales by both Category and Region
var salesByCategoryAndRegion = sales
    .GroupBy(
        sale => new { sale.Category, sale.Region } // Composite key selector
    );

Console.WriteLine("Sales Grouped by Category and Region:");
foreach (var group in salesByCategoryAndRegion)
{
    Console.WriteLine($"--- Key: Category='{group.Key.Category}', Region='{group.Key.Region}' ---");
    foreach (var sale in group)
    {
        Console.WriteLine($"  Amount: ${sale.Amount}");
    }
}
</code></pre>
                <div class="code-result">
                    Sales Grouped by Category and Region:
                    --- Key: Category='Electronics', Region='North' ---
                    Amount: $1000
                    Amount: $500
                    --- Key: Category='Furniture', Region='South' ---
                    Amount: $750
                    --- Key: Category='Clothing', Region='East' ---
                    Amount: $250
                    --- Key: Category='Electronics', Region='South' ---
                    Amount: $800
                    --- Key: Category='Furniture', Region='North' ---
                    Amount: $1200
                    --- Key: Category='Clothing', Region='West' ---
                    Amount: $300
                </div>

                <h5 class="text-lg font-medium mt-4">Grouping with Result Projection</h5>
                <p>Transform the groups directly into a summary object during the grouping operation.</p>
                <pre><code class="language-csharp">var regionStats = sales
    .GroupBy(
        sale => sale.Region, // Key selector: group by Region
        (regionKey, salesInRegion) => new // Result selector
        {
            Region = regionKey,
            TotalSales = salesInRegion.Sum(s => s.Amount),
            NumberOfSales = salesInRegion.Count(),
            AverageSale = salesInRegion.Average(s => s.Amount)
        }
    )
    .OrderByDescending(stat => stat.TotalSales); // Order the final results

Console.WriteLine("\nRegion Sales Statistics:");
foreach (var stat in regionStats)
{
    Console.WriteLine($"- {stat.Region}: Total=${stat.TotalSales:F2}, Count={stat.NumberOfSales}, Avg=${stat.AverageSale:F2}");
}
</code></pre>
                <div class="code-result">
                    Region Sales Statistics:
                    - North: Total=$2700.00, Count=3, Avg=$900.00
                    - South: Total=$1550.00, Count=2, Avg=$775.00
                    - West: Total=$300.00, Count=1, Avg=$300.00
                    - East: Total=$250.00, Count=1, Avg=$250.00
                </div>

                <h4 class="text-xl font-medium mt-6">Joining (`Join`, `GroupJoin`)</h4>
                <p>Method syntax provides `Join` (for inner joins) and `GroupJoin` (similar to query syntax's
                    `join...into`).</p>
                <div class="example-class-definitions">
                    <h5 class="text-lg font-medium">Sample Data for Join Examples</h5>
                    <pre><code class="language-csharp">List&lt;Employee&gt; employees = ExampleData.employees; // Use previous definition
List&lt;Department&gt; departments = [
    new() { Name = "HR", Location = "Building A" },
    new() { Name = "IT", Location = "Building B" },
    new() { Name = "Finance", Location = "Building A" },
    new() { Name = "Sales", Location = "Building C" } // Dept with no employees in our list
];</code></pre>
                </div>
                <pre><code class="language-csharp">// Inner Join using Join method
var employeeLocations = employees.Join(
    departments,                        // Inner sequence to join with
    emp => emp.Department,              // Outer key selector (from employees)
    dept => dept.Name,                  // Inner key selector (from departments)
    (employee, department) => new       // Result selector
    {
        EmployeeName = employee.Name,
        DepartmentName = department.Name,
        Location = department.Location
    }
);

Console.WriteLine("Employee Locations (Inner Join):");
foreach(var item in employeeLocations) {
    Console.WriteLine($"- {item.EmployeeName} in {item.DepartmentName} at {item.Location}");
}

// Group Join (often used for Left Outer Join simulation)
var departmentEmployees = departments.GroupJoin(
    employees,                          // Inner sequence
    dept => dept.Name,                  // Outer key selector (from departments)
    emp => emp.Department,              // Inner key selector (from employees)
    (department, employeesInDept) => new // Result selector
    {
        DepartmentName = department.Name,
        Location = department.Location,
        Employees = employeesInDept // This is IEnumerable&lt;Employee&gt;
    }
);

Console.WriteLine("\nEmployees by Department (Group Join):");
foreach (var deptInfo in departmentEmployees) {
    Console.WriteLine($"- Department: {deptInfo.DepartmentName} ({deptInfo.Location})");
    if (deptInfo.Employees.Any()) {
        foreach (var emp in deptInfo.Employees) {
            Console.WriteLine($"  * {emp.Name}");
        }
    } else {
        Console.WriteLine("  (No employees)");
    }
}

// Simulating Left Outer Join using GroupJoin and SelectMany
var leftOuterJoinData = departments.GroupJoin(
    employees,
    dept => dept.Name,
    emp => emp.Department,
    (dept, emps) => new { dept, emps }
)
.SelectMany(
    temp => temp.emps.DefaultIfEmpty(), // Flatten, providing null if no match
    (temp, emp) => new {
        DepartmentName = temp.dept.Name,
        EmployeeName = emp?.Name ?? "(No Employee)" // Use null-conditional/coalescing
    }
);

Console.WriteLine("\nDepartment/Employee List (Left Outer Join):");
foreach(var item in leftOuterJoinData) {
    Console.WriteLine($"- Department: {item.DepartmentName}, Employee: {item.EmployeeName}");
}
</code></pre>
                <div class="code-result">
                    Employee Locations (Inner Join):
                    - Alice in HR at Building A
                    - Bob in IT at Building B
                    - Charlie in Finance at Building A
                    - David in IT at Building B
                    - Eve in HR at Building A

                    Employees by Department (Group Join):
                    - Department: HR (Building A)
                    * Alice
                    * Eve
                    - Department: IT (Building B)
                    * Bob
                    * David
                    - Department: Finance (Building A)
                    * Charlie
                    - Department: Sales (Building C)
                    (No employees)

                    Department/Employee List (Left Outer Join):
                    - Department: HR, Employee: Alice
                    - Department: HR, Employee: Eve
                    - Department: IT, Employee: Bob
                    - Department: IT, Employee: David
                    - Department: Finance, Employee: Charlie
                    - Department: Sales, Employee: (No Employee)
                </div>

                <h4 class="text-xl font-medium mt-6">Combining Sequences: `Zip`</h4>
                <p>The <code>Zip</code> operator merges two sequences by applying a function to corresponding elements.
                    The resulting sequence length is the minimum of the input sequence lengths.</p>
                <pre><code class="language-csharp">List&lt;string&gt; itemNames = ["Laptop", "Mouse", "Keyboard", "Monitor"];
List&lt;decimal&gt; itemPrices = [1200m, 25m, 75m]; // Shorter list
List&lt;int&gt; itemQuantities = [2, 5, 3, 1];

// Zip two sequences
var namePricePairs = itemNames.Zip(itemPrices, (name, price) => $"{name}: ${price}");
Console.WriteLine("Name/Price Pairs: " + string.Join(", ", namePricePairs)); // Stops after 3 items

// Zip three sequences (available in more recent .NET versions)
var itemDetails = itemNames.Zip(itemPrices, itemQuantities,
    (name, price, quantity) => new {
        Name = name,
        Price = price,
        Quantity = quantity,
        TotalValue = price * quantity
    });

Console.WriteLine("\nItem Details (Zip of 3):");
foreach(var item in itemDetails) {
    Console.WriteLine($"- {item.Name}: Qty={item.Quantity}, Price=${item.Price}, Total=${item.TotalValue}");
}
</code></pre>
                <div class="code-result">
                    Name/Price Pairs: Laptop: $1200, Mouse: $25, Keyboard: $75

                    Item Details (Zip of 3):
                    - Laptop: Qty=2, Price=$1200, Total=$2400
                    - Mouse: Qty=5, Price=$25, Total=$125
                    - Keyboard: Qty=3, Price=$75, Total=$225
                </div>

                <h4 class="text-xl font-medium mt-6">Generation Operators</h4>
                <p>Create simple sequences.</p>
                <pre><code class="language-csharp">// Range: Generates a sequence of integers within a specified range
var oneToTen = Enumerable.Range(1, 10); // Start=1, Count=10
Console.WriteLine("Range(1, 10): " + string.Join(", ", oneToTen));

// Repeat: Generates a sequence by repeating a value N times
var fiveZeros = Enumerable.Repeat(0, 5); // Element=0, Count=5
Console.WriteLine("Repeat(0, 5): " + string.Join(", ", fiveZeros));

// Empty: Creates an empty sequence of a specified type
var emptyStrings = Enumerable.Empty&lt;string&gt;();
Console.WriteLine($"Is emptyStrings empty? {!emptyStrings.Any()}");
</code></pre>
                <div class="code-result">
                    Range(1, 10): 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
                    Repeat(0, 5): 0, 0, 0, 0, 0
                    Is emptyStrings empty? True
                </div>

                <h4 class="text-xl font-medium mt-6">Conversion Operators</h4>
                <p>Convert sequence types or handle type mismatches.</p>
                <pre><code class="language-csharp">List&lt;object&gt; mixedList = ["Hello", 123, null, DateTime.Now, "World", 456];

// OfType&lt;T&gt;: Filters elements based on their type and returns only elements of type T
var stringsOnly = mixedList.OfType&lt;string&gt;();
Console.WriteLine("Strings Only: " + string.Join(", ", stringsOnly));

var intsOnly = mixedList.OfType&lt;int&gt;();
Console.WriteLine("Integers Only: " + string.Join(", ", intsOnly));

// Cast&lt;T&gt;: Attempts to cast all elements to type T. Throws an exception if any element cannot be cast.
// Use with caution, often after filtering or if you are certain of the types.
// List&lt;object&gt; mostlyInts = [1, 2, 3, "Oops", 5];
// var castToInts = mostlyInts.Cast&lt;int&gt;(); // This would throw InvalidCastException at "Oops"

List&lt;object&gt; allInts = [10, 20, 30];
var definitelyInts = allInts.Cast&lt;int&gt;();
Console.WriteLine("Casted Ints: " + string.Join(", ", definitelyInts));

// AsEnumerable: Casts to IEnumerable&lt;T&gt;. Useful in LINQ to Entities to force remaining operations
// to execute in memory (client-side evaluation).
// Example with hypothetical IQueryable
// var queryable = dbContext.Products.Where(p => p.IsActive); // IQueryable
// var enumerable = queryable.AsEnumerable(); // Cast to IEnumerable for client-side processing
</code></pre>
                <div class="code-result">
                    Strings Only: Hello, World
                    Integers Only: 123, 456
                    Casted Ints: 10, 20, 30
                </div>
            </div>

            <div class="section">
                <h3 id="working-collections" class="text-2xl font-semibold">Working with Collections</h3>

                <p>
                    LINQ provides a unified query experience, but understanding the characteristics of the underlying
                    collection types (<code>List&lt;T&gt;</code>, <code>T[]</code>,
                    <code>Dictionary&lt;TKey, TValue&gt;</code>, <code>HashSet&lt;T&gt;</code>, etc.) can help you write
                    more efficient queries and leverage collection-specific features.
                </p>

                <h4 class="text-xl font-medium mt-6">Querying Arrays (`T[]`) and Lists (`List&lt;T&gt;`)</h4>
                <p>Arrays and Lists are the most common sequential collections. They both implement
                    <code>IEnumerable&lt;T&gt;</code>, so all standard LINQ operators work seamlessly.
                </p>
                <pre><code class="language-csharp">// --- Arrays ---
string[] fruitsArray = ["Apple", "Banana", "Cherry", "Date", "Elderberry"];

// Standard LINQ on arrays
var fruitsStartingWithC = fruitsArray.Where(f => f.StartsWith("C"));
Console.WriteLine("Array - Fruits starting with C: " + string.Join(", ", fruitsStartingWithC));

// Get element by index (efficient for arrays)
string thirdFruit = fruitsArray[2]; // Cherry

// --- Lists ---
List&lt;int&gt; scoresList = [95, 80, 72, 98, 85];

// Standard LINQ on lists
var highScores = scoresList.Where(s => s >= 90);
Console.WriteLine("List - High scores: " + string.Join(", ", highScores));

// List-specific methods
scoresList.Add(78); // Add element
scoresList.Sort(); // Sort list in-place
bool removed = scoresList.Remove(72); // Remove specific element
scoresList.Insert(0, 100); // Insert at specific index

Console.WriteLine("Modified List: " + string.Join(", ", scoresList));

// FindIndex (List specific)
int indexOf98 = scoresList.FindIndex(s => s == 98);
Console.WriteLine($"Index of 98: {indexOf98}");

// Using LINQ and converting back
int[] top3ScoresArray = scoresList.OrderByDescending(s => s).Take(3).ToArray();
Console.WriteLine("Top 3 Scores (Array): " + string.Join(", ", top3ScoresArray));
</code></pre>
                <div class="code-result">
                    Array - Fruits starting with C: Cherry
                    List - High scores: 95, 98
                    Modified List: 78, 80, 85, 95, 98, 100
                    Index of 98: 4
                    Top 3 Scores (Array): 100, 98, 95
                </div>
                <div class="tip">
                    <strong>Tip:</strong> While LINQ works on both, <code>List&lt;T&gt;</code> offers more mutation
                    methods (Add, Remove, Insert, Sort in-place) than arrays. Use arrays when the size is fixed or for
                    performance-critical scenarios involving direct index access. Use <code>List&lt;T&gt;</code> for
                    dynamic collections.
                </div>

                <h4 class="text-xl font-medium mt-6">Querying Dictionaries (`Dictionary&lt;TKey, TValue&gt;`)</h4>
                <p>Dictionaries store key-value pairs. LINQ operates on the dictionary as a sequence of
                    <code>KeyValuePair&lt;TKey, TValue&gt;</code> objects.
                </p>
                <pre><code class="language-csharp">Dictionary&lt;string, int&gt; productStock = new() {
    ["Laptop"] = 15,
    ["Mouse"] = 120,
    ["Keyboard"] = 75,
    ["Monitor"] = 0,
    ["Webcam"] = 30
};

// Querying KeyValuePairs
var lowStockItems = productStock
    .Where(kvp => kvp.Value < 50 && kvp.Value > 0); // Query based on Value

Console.WriteLine("Low Stock Items (Name: Stock):");
foreach (var kvp in lowStockItems)
{
    Console.WriteLine($"- {kvp.Key}: {kvp.Value}");
}

// Querying Keys
var itemNames = productStock.Keys.OrderBy(name => name);
Console.WriteLine("\nItem Names (Sorted): " + string.Join(", ", itemNames));

// Querying Values
int totalStock = productStock.Values.Sum();
Console.WriteLine($"\nTotal Stock: {totalStock}");

// Selecting into a new structure
var stockInfo = productStock
    .Select(kvp => $"Product '{kvp.Key}' has stock {kvp.Value}");
Console.WriteLine("\nStock Info:");
foreach(var info in stockInfo) Console.WriteLine(info);

// Checking for key/value existence
bool hasMouse = productStock.ContainsKey("Mouse"); // Efficient O(1) lookup
bool hasZeroStockItem = productStock.ContainsValue(0); // Less efficient O(n) scan

// Converting LINQ results ToDictionary
var highStockDict = productStock
    .Where(kvp => kvp.Value >= 100)
    .ToDictionary(kvp => kvp.Key, kvp => kvp.Value); // Creates a new dictionary
</code></pre>
                <div class="code-result">
                    Low Stock Items (Name: Stock):
                    - Laptop: 15
                    - Webcam: 30

                    Item Names (Sorted): Keyboard, Laptop, Monitor, Mouse, Webcam

                    Total Stock: 240

                    Stock Info:
                    Product 'Laptop' has stock 15
                    Product 'Mouse' has stock 120
                    Product 'Keyboard' has stock 75
                    Product 'Monitor' has stock 0
                    Product 'Webcam' has stock 30
                </div>

                <h4 class="text-xl font-medium mt-6">Querying Sets (`HashSet&lt;T&gt;`)</h4>
                <p><code>HashSet&lt;T&gt;</code> stores unique elements and provides highly efficient set operations
                    (add, remove, contains - typically O(1)). LINQ can query it like any
                    <code>IEnumerable&lt;T&gt;</code>, but HashSets also have optimized set methods.
                </p>
                <pre><code class="language-csharp">HashSet&lt;string&gt; tags1 = ["csharp", "linq", "dotnet", "performance"];
HashSet&lt;string&gt; tags2 = ["java", "dotnet", "web", "csharp"];

// LINQ on HashSet
var shortTags = tags1.Where(tag => tag.Length <= 4);
Console.WriteLine("Short Tags: " + string.Join(", ", shortTags));

// Optimized HashSet set operations
tags1.UnionWith(tags2); // Modifies tags1 in-place to include elements from tags2
Console.WriteLine("\nUnion (in-place): " + string.Join(", ", tags1));

// Reset for next example
tags1 = ["csharp", "linq", "dotnet", "performance"];

tags1.IntersectWith(tags2); // Modifies tags1 to keep only common elements
Console.WriteLine("Intersection (in-place): " + string.Join(", ", tags1));

// Reset for next example
tags1 = ["csharp", "linq", "dotnet", "performance"];

bool isSubset = tags1.IsSubsetOf(tags2); // Check if tags1 is a subset of tags2
Console.WriteLine($"\nIs tags1 subset of tags2? {isSubset}"); // False

bool isSuperset = tags1.IsSupersetOf(["csharp", "linq"]); // Check if tags1 contains all specified elements
Console.WriteLine($"Is tags1 superset of ['csharp', 'linq']? {isSuperset}"); // True

// Contains check (efficient O(1))
bool hasLinq = tags1.Contains("linq");
</code></pre>
                <div class="code-result">
                    Short Tags: linq
                    Union (in-place): csharp, linq, dotnet, performance, java, web
                    Intersection (in-place): csharp, dotnet
                    Is tags1 subset of tags2? False
                    Is tags1 superset of ['csharp', 'linq']? True
                </div>

                <h4 class="text-xl font-medium mt-6">Handling Nulls and Exceptions in LINQ Queries</h4>
                <p>Real-world data isn't always perfect. Collections might be null, elements within collections might be
                    null, or operations within a query might throw exceptions.</p>

                <h5 class="text-lg font-medium mt-4">Handling Null Collections</h5>
                <pre><code class="language-csharp">List&lt;string&gt;? GetNames(bool succeed) => succeed ? ["Alice", "Bob"] : null;

// Unsafe - throws NullReferenceException if GetNames returns null
// var queryUnsafe = GetNames(false).Where(n => n.Length > 3);

// Safe - Null conditional operator (?.) and null coalescing operator (??)
IEnumerable&lt;string&gt; querySafe = GetNames(false) // If GetNames returns null...
                                    ?.Where(n => n.Length > 3) // ...this part is skipped...
                                    ?? Enumerable.Empty&lt;string&gt;(); // ...and we use an empty list instead.

Console.WriteLine($"Safe query result count: {querySafe.Count()}");

// Alternative: Explicit null check
List&lt;string&gt;? names = GetNames(true);
IEnumerable&lt;string&gt; queryExplicit = Enumerable.Empty&lt;string&gt;();
if (names != null)
{
    queryExplicit = names.Where(n => n.Length > 3);
}
Console.WriteLine($"Explicit query result count: {queryExplicit.Count()}");
</code></pre>
                <div class="code-result">
                    Safe query result count: 0
                    Explicit query result count: 1
                </div>

                <h5 class="text-lg font-medium mt-4">Handling Null Elements Within Collections</h5>
                <pre><code class="language-csharp">List&lt;string?&gt; messages = ["Msg1", null, "Message 2", "Msg3", null];

// Filter out nulls before processing
var nonNullMessages = messages
    .Where(msg => msg != null)
    .Select(msg => msg!.ToUpper()); // Use null-forgiving operator (!) after check

Console.WriteLine("Non-Null Messages (Upper): " + string.Join(", ", nonNullMessages));

// Use OfType&lt;T&gt; to filter non-nulls and get correct type
var validMessages = messages.OfType&lt;string&gt;();
Console.WriteLine("Valid Messages (OfType): " + string.Join(", ", validMessages));

// Safely accessing properties on potentially null objects in a list
List&lt;Person?&gt; peopleWithNulls = [ new() { Name = "Alice", Age = 30 }, null, new() { Name = "Bob", Age = 25 } ];

var namesOfAdults = peopleWithNulls
    .Where(p => p?.Age >= 18) // Null-conditional access in Where
    .Select(p => p!.Name);    // Null-forgiving after filtering

Console.WriteLine("\nNames of Adults (from list with nulls): " + string.Join(", ", namesOfAdults));
</code></pre>
                <div class="code-result">
                    Non-Null Messages (Upper): MSG1, MESSAGE 2, MSG3
                    Valid Messages (OfType): Msg1, Message 2, Msg3
                    Names of Adults (from list with nulls): Alice, Bob
                </div>

                <h5 class="text-lg font-medium mt-4">Handling Exceptions within LINQ Queries</h5>
                <p>Operations within <code>Select</code>, <code>Where</code>, etc., might throw exceptions (e.g.,
                    parsing errors, invalid data). Due to deferred execution, these exceptions often occur during
                    enumeration, not definition.</p>
                <pre><code class="language-csharp">List&lt;string&gt; inputs = ["10", "20", "invalid", "30", "another bad one", "40"];

// Unsafe - int.Parse will throw FormatException
// var parsedUnsafe = inputs.Select(s => int.Parse(s));
// foreach (var num in parsedUnsafe) { } // Exception occurs here

// Safe - Use int.TryParse within Select
var parsedSafe = inputs.Select(s => {
    bool success = int.TryParse(s, out int result);
    return new { Success = success, Value = success ? result : 0 }; // Project success and value
});

Console.WriteLine("Safely Parsed Values (0 for errors):");
foreach (var item in parsedSafe) {
    if(item.Success) Console.Write($"{item.Value} ");
    else Console.Write("[ERR] ");
} // Output: 10 20 [ERR] 30 [ERR] 40

// Filter out invalid entries before parsing
var validNumbers = inputs
    .Where(s => int.TryParse(s, out _)) // Filter first
    .Select(s => int.Parse(s));         // Now Parse is safe

Console.WriteLine("\n\nValid Numbers Only:");
Console.WriteLine(string.Join(", ", validNumbers)); // Output: 10, 20, 30, 40

// Catching exceptions during enumeration (less ideal than preventing them)
Console.WriteLine("\nCatching during enumeration:");
var queryWithPotentialException = inputs.Select(s => int.Parse(s)); // Define query

try
{
    // The exception happens inside the loop
    foreach (var number in queryWithPotentialException)
    {
        Console.WriteLine($"Processed: {number}");
    }
}
catch (FormatException ex)
{
    Console.WriteLine($"Error during enumeration: {ex.Message}");
}
</code></pre>
                <div class="code-result">
                    Safely Parsed Values (0 for errors):
                    10 20 [ERR] 30 [ERR] 40

                    Valid Numbers Only:
                    10, 20, 30, 40

                    Catching during enumeration:
                    Processed: 10
                    Processed: 20
                    Error during enumeration: The input string 'invalid' was not in a correct format.
                </div>
                <div class="warning">
                    <strong>Best Practice:</strong> It's generally better to prevent exceptions within LINQ
                    predicates/projections (e.g., using `TryParse`, null checks) rather than relying on catching them
                    during enumeration, especially for recoverable errors. Handle exceptions within the lambda if
                    necessary, or filter out problematic data first.
                </div>
            </div>

            <div class="section">
                <h3 id="best-practices" class="text-2xl font-semibold">LINQ Best Practices</h3>

                <p>
                    Writing effective LINQ involves more than just knowing the syntax. Following best practices ensures
                    your queries are readable, maintainable, and performant.
                </p>

                <h4 class="text-xl font-medium mt-6">1. Avoid Multiple Enumerations</h4>
                <p>
                    This is one of the most common performance pitfalls. Because of deferred execution, iterating over
                    an <code>IEnumerable&lt;T&gt;</code> query variable multiple times re-executes the entire query
                    pipeline. If the query is expensive (e.g., involves complex calculations or database access), this
                    can be very inefficient.
                </p>
                <pre><code class="language-csharp">// Inefficient Example
IEnumerable&lt;int&gt; complexQuery = Enumerable.Range(1, 1000)
                                        .Select(i => i * i) // Some work
                                        .Where(i => i % 7 == 0); // More work

Console.WriteLine("Inefficient Approach:");
// Execution 1: Count() iterates the whole query
int count = complexQuery.Count();
Console.WriteLine($"Count: {count}");

// Execution 2: Sum() iterates the whole query again
long sum = complexQuery.Sum(i => (long)i);
Console.WriteLine($"Sum: {sum}");

// Execution 3: foreach iterates the whole query again
Console.WriteLine("First 5 items:");
foreach (var item in complexQuery.Take(5)) {
    Console.WriteLine($"- {item}");
}

// Efficient Example: Materialize once
Console.WriteLine("\nEfficient Approach:");
List&lt;int&gt; resultsList = complexQuery.ToList(); // Execute query ONCE and store results

// Use the list - fast in-memory operations
int countEfficient = resultsList.Count;
Console.WriteLine($"Count: {countEfficient}");

long sumEfficient = resultsList.Sum(i => (long)i);
Console.WriteLine($"Sum: {sumEfficient}");

Console.WriteLine("First 5 items:");
foreach (var item in resultsList.Take(5)) {
    Console.WriteLine($"- {item}");
}
</code></pre>
                <div class="tip"><strong>Rule of Thumb:</strong> If you need to access the results of a non-trivial LINQ
                    query more than once, call <code>ToList()</code> or <code>ToArray()</code> and work with the
                    resulting collection.</div>

                <h4 class="text-xl font-medium mt-6">2. Filter Early, Project Late</h4>
                <p>Perform filtering operations (<code>Where</code>) as early as possible in the query chain. This
                    reduces the number of elements that subsequent operations (like complex projections or sorting) need
                    to process.</p>
                <pre><code class="language-csharp">List&lt;Product&gt; products = ExampleData.GetProducts(); // Assume this is large

// Less efficient: Projects all products first, then filters
var lessEfficient = products
    .Select(p => new { // Project potentially many items
        p.Id,
        p.Name,
        NormalizedName = p.Name.ToUpperInvariant(), // Work done on all items
        CategoryInfo = GetCategoryDetails(p.Category) // More work on all items
    })
    .Where(pInfo => pInfo.CategoryInfo.IsFeatured); // Filter late

// More efficient: Filters first, then projects only the needed items
var moreEfficient = products
    .Where(p => GetCategoryDetails(p.Category).IsFeatured) // Filter early
    .Select(p => new { // Project fewer items
        p.Id,
        p.Name,
        NormalizedName = p.Name.ToUpperInvariant(), // Work done only on filtered items
        CategoryInfo = GetCategoryDetails(p.Category) // Work done only on filtered items
    });

// Dummy helper method
static CategoryDetails GetCategoryDetails(string category) => new CategoryDetails { IsFeatured = (category == "Electronics") };
class CategoryDetails { public bool IsFeatured { get; set; } }
</code></pre>
                <p>This is especially important with LINQ to Entities/SQL, as filtering early translates to more
                    efficient SQL <code>WHERE</code> clauses, transferring less data from the database.</p>

                <h4 class="text-xl font-medium mt-6">3. Understand `IEnumerable<T>` vs. `IQueryable<T>`</h4>
                <p>While both represent sequences, they behave differently:</p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>`IEnumerable&lt;T&gt;` (e.g., LINQ to Objects):</strong> Works with in-memory
                        collections. LINQ methods execute using delegates (lambda expressions). Deferred execution
                        happens, but processing occurs within your application's memory.</li>
                    <li><strong>`IQueryable&lt;T&gt;` (e.g., LINQ to Entities/SQL):</strong> Represents a query that can
                        be executed by an external provider (like a database). LINQ methods build an *expression tree*
                        representing the query. This tree is translated by the provider (e.g., EF Core) into the native
                        query language (e.g., SQL). Execution is deferred until enumeration or a materializing operator
                        is called, at which point the translated query is sent to the data source.</li>
                </ul>
                <pre><code class="language-csharp">// IEnumerable - Operations run in memory
IEnumerable&lt;Product&gt; inMemoryProducts = ExampleData.GetProducts();
var filteredInMemory = inMemoryProducts
                        .Where(p => p.Price > 100) // Executed in .NET runtime
                        .OrderBy(p => p.Name);     // Executed in .NET runtime

// IQueryable - Operations translated to SQL
using var context = new ECommerceContext();
// Seed data
if (!context.Products.Any()) { context.Products.AddRange(ExampleData.GetProducts()); context.SaveChanges(); }

IQueryable&lt;Product&gt; dbProducts = context.Products;
var filteredDb = dbProducts
                    .Where(p => p.Price > 100) // Translated to SQL WHERE clause
                    .OrderBy(p => p.Name);     // Translated to SQL ORDER BY clause

// SQL Execution happens here when ToList is called
List&lt;Product&gt; results = filteredDb.ToList();
Console.WriteLine($"Fetched {results.Count} products from DB.");

// --- The Pitfall: Mixing IQueryable and IEnumerable ---
var potentiallyInefficient = context.Products // IQueryable
    .Where(p => p.Category == "Electronics") // Executed in DB (good)
    .AsEnumerable() // *** Switches to in-memory processing ***
    .Where(p => p.Name.Contains("o")); // Executed in memory (potentially on many rows)

var usuallyBetter = context.Products // IQueryable
    .Where(p => p.Category == "Electronics" && p.Name.Contains("o")) // Both filters translated to SQL
    .ToList(); // Execute efficient SQL
</code></pre>
                <div class="warning"><strong>Beware `AsEnumerable()`:</strong> Calling <code>AsEnumerable()</code> on an
                    <code>IQueryable&lt;T&gt;</code> forces the rest of the query to execute in memory. Use it
                    deliberately when you need LINQ operators not supported by the database provider, but understand
                    that it might pull large amounts of data from the database first. Filter as much as possible
                    *before* calling <code>AsEnumerable()</code>.
                </div>

                <h4 class="text-xl font-medium mt-6">4. Optimize Predicates and Projections</h4>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Order conditions in `Where` clauses:</strong> Place cheaper/more selective conditions
                        first to short-circuit evaluation earlier.</li>
                    <li><strong>Avoid complex logic inside lambdas if possible:</strong> Complex logic might hinder
                        database translation or be slow in memory. Pre-calculate values if feasible.</li>
                    <li><strong>Project only necessary data (`Select`):</strong> Especially with databases, avoid
                        selecting columns you don't need (<code>SELECT *</code> anti-pattern). Create specific DTOs or
                        use anonymous types.</li>
                </ul>
                <pre><code class="language-csharp">// Predicate order (in-memory example)
var filtered = employees
    .Where(e => e.IsActive) // Assume IsActive is quick check
    .Where(e => CalculateComplexMetric(e) > 0.5); // Complex check later

// Projection (database example)
using var context = new ECommerceContext();
// Bad: Selects all columns, even if only Name/Email needed later
var allColumns = context.Customers.Where(c => c.IsActive).ToList();

// Good: Selects only required columns
var partialColumns = context.Customers
    .Where(c => c.IsActive)
    .Select(c => new { c.Name, c.Email }) // Anonymous type
    .ToList();

// Better: Selects into a specific DTO (Data Transfer Object)
var customerDtos = context.Customers
    .Where(c => c.IsActive)
    .Select(c => new CustomerDto { Id = c.Id, FullName = c.Name, ContactEmail = c.Email })
    .ToList();

// Dummy methods/classes for example
static bool CalculateComplexMetric(Employee e) => (e.Salary / (e.Age + 1.0m)) > 1000;
public record CustomerDto { public int Id; public string FullName = ""; public string ContactEmail = ""; }
</code></pre>

                <h4 class="text-xl font-medium mt-6">5. Leverage Specialized Collections</h4>
                <p>Use appropriate collection types for the task. LINQ's <code>ToDictionary()</code> and
                    <code>ToHashSet()</code> can be very useful.
                </p>
                <pre><code class="language-csharp">List&lt;Product&gt; productList = ExampleData.GetProducts();

// Need fast lookup by ID? Convert to Dictionary.
Dictionary&lt;int, Product&gt; productsById = productList.ToDictionary(p => p.Id);
Product? product2 = productsById.TryGetValue(2, out var p) ? p : null; // Efficient O(1) lookup

// Need to check for existence of categories quickly? Convert to HashSet.
HashSet&lt;string&gt; uniqueCategories = productList.Select(p => p.Category).ToHashSet();
if (uniqueCategories.Contains("Electronics")) // Efficient O(1) check
{
    Console.WriteLine("Electronics category exists.");
}
</code></pre>

                <h4 class="text-xl font-medium mt-6">6. Consider Parallel LINQ (`AsParallel()`) Carefully</h4>
                <p>PLINQ can speed up CPU-bound operations on large, in-memory collections by utilizing multiple cores.
                    However, it introduces overhead and complexity.</p>
                <pre><code class="language-csharp">List&lt;int&gt; largeData = Enumerable.Range(1, 10_000_000).ToList();

// CPU-bound work: calculate something complex for each item
Func&lt;int, double&gt; ComplexCalculation = n => Math.Sqrt(Math.Log(n + 1) * Math.Sin(n / 1000.0));

// Sequential LINQ
var sequentialResults = largeData
    .Select(ComplexCalculation)
    .Where(r => r > 0.5)
    .Average();

// Parallel LINQ
var parallelResults = largeData
    .AsParallel() // Enable parallel execution
    .Select(ComplexCalculation)
    .Where(r => r > 0.5)
    .Average();

// Use AsOrdered() if the order of elements matters for subsequent steps
var orderedParallel = largeData
    .AsParallel()
    .AsOrdered()
    .Select(ComplexCalculation)
    .Take(100); // Takes the first 100 results *in the original order*

// Limit degree of parallelism
var limitedParallel = largeData
    .AsParallel()
    .WithDegreeOfParallelism(4) // Use max 4 cores
    .Select(ComplexCalculation)
    .Sum();
</code></pre>
                <div class="note">
                    <strong>When to use PLINQ:</strong>
                    <ul class="list-disc pl-4 mt-2">
                        <li>The operations within LINQ (lambdas in <code>Select</code>, <code>Where</code>, etc.) are
                            CPU-bound and take significant time per element.</li>
                        <li>The dataset is large enough to overcome the overhead of parallelization.</li>
                        <li>The source is an in-memory collection (<code>IEnumerable&lt;T&gt;</code>). PLINQ doesn't
                            directly parallelize database queries.</li>
                        <li>Order doesn't matter, or you explicitly manage it with <code>AsOrdered()</code>.</li>
                    </ul>
                    <strong>When NOT to use PLINQ:</strong>
                    <ul class="list-disc pl-4 mt-2">
                        <li>Operations are I/O-bound (like file access or network calls). Use async/await instead.</li>
                        <li>The dataset is small.</li>
                        <li>The per-element workload is trivial.</li>
                        <li>The code inside the lambdas is not thread-safe.</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Part 4: Advanced LINQ and C# 14 Integration -->
        <div class="chapter">
            <h2 class="text-3xl font-bold">Part 4: Advanced LINQ and C# 14 Integration</h2>

            <div class="section">
                <h3 id="csharp14-features" class="text-2xl font-semibold">LINQ with C# 14 Features</h3>

                <p>
                    C# continues to evolve, and new language features often enhance how we write and use LINQ. While C#
                    14 specifics are projected, features from recent versions like C# 12 (collection expressions,
                    primary constructors) already significantly impact LINQ usage.
                </p>

                <h4 class="text-xl font-medium mt-6">Collection Expressions and LINQ</h4>
                <p>
                    Introduced in C# 12, collection expressions <code>[...]</code> provide a unified, concise syntax for
                    creating common collection types (arrays, lists, spans). They integrate naturally with LINQ.
                </p>
                <pre><code class="language-csharp">// Creating source collections concisely
var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // Infers int[]
List&lt;string&gt; names = ["Alice", "Bob", "Charlie"]; // Target-typed to List&lt;string&gt;

// Using collection expressions directly in LINQ chains
var firstEvens = [1, 2, 3, 4, 5].Where(n => n % 2 == 0); // Query directly on expression

// Combining collections using the spread `..` operator
var combined = [..numbers, ..firstEvens, 11, 12]; // Combine existing collections/queries
Console.WriteLine($"Combined: {string.Join(", ", combined.Distinct().OrderBy(n => n))}");

// Using in LINQ projections
var coordinates = employees.Select(e => [e.Id, e.Salary]); // Project to int[] implicitly
// Requires target typing if not array:
// IEnumerable&lt;List&lt;decimal&gt;&gt; coordinateLists = employees.Select(e => (List&lt;decimal&gt;)[e.Id, e.Salary]);

// Using with ToList/ToArray
var highEarnersArray = employees
    .Where(e => e.Salary > 70000)
    .Select(e => e.Name)
    .ToArray(); // Materialize result

var highEarnersList = employees
    .Where(e => e.Salary > 70000)
    .Select(e => e.Name)
    .ToList(); // Materialize result
</code></pre>

                <h4 class="text-xl font-medium mt-6">Primary Constructors and Records with LINQ</h4>
                <p>
                    Primary constructors (available for classes and structs since C# 12, earlier for records) simplify
                    type definitions, making them ideal for creating DTOs or temporary objects within LINQ projections.
                    Records, with their value-based equality and concise syntax, are particularly well-suited.
                </p>
                <pre><code class="language-csharp">// Define a record with a primary constructor
public record EmployeeInfo(int Id, string Name, string Department);

// Define a class with a primary constructor (C# 12+)
public class SalaryInfo(decimal Amount)
{
    public decimal AnnualAmount { get; } = Amount;
    public decimal MonthlyAmount => AnnualAmount / 12;
}

// Using records in LINQ Select
var employeeInfos = employees
    .Where(e => e.Department == "IT")
    .Select(e => new EmployeeInfo(e.Id, e.Name, e.Department)); // Concise projection

Console.WriteLine("IT Employee Infos (Records):");
foreach(var info in employeeInfos) {
    Console.WriteLine($"- ID: {info.Id}, Name: {info.Name}, Dept: {info.Department}");
}

// Using classes with primary constructors
var salaryInfos = employees
    .OrderByDescending(e => e.Salary)
    .Select(e => new SalaryInfo(e.Salary)); // Project to SalaryInfo

Console.WriteLine("\nSalary Infos (Classes):");
foreach(var salary in salaryInfos) {
    Console.WriteLine($"- Annual: ${salary.AnnualAmount:F2}, Monthly: ${salary.MonthlyAmount:F2}");
}

// Records work well as keys in GroupBy due to value equality
var countByDeptRecordKey = employees
    .Select(e => new EmployeeInfo(e.Id, e.Name, e.Department))
    .GroupBy(info => info.Department) // Grouping by string is simple here
    .Select(g => new { Department = g.Key, Count = g.Count() });
</code></pre>
                <div class="code-result">
                    IT Employee Infos (Records):
                    - ID: 2, Name: Bob, Dept: IT
                    - ID: 4, Name: David, Dept: IT

                    Salary Infos (Classes):
                    - Annual: $80000.00, Monthly: $6666.67
                    - Annual: $75000.00, Monthly: $6250.00
                    - Annual: $65000.00, Monthly: $5416.67
                    - Annual: $60000.00, Monthly: $5000.00
                    - Annual: $55000.00, Monthly: $4583.33
                </div>

                <h4 class="text-xl font-medium mt-6">Enhanced Pattern Matching in LINQ</h4>
                <p>
                    C# continues to enhance pattern matching. Features like property patterns, list patterns, and type
                    patterns can be used within LINQ queries (especially <code>Where</code> and <code>Select</code> with
                    switch expressions) for more expressive filtering and transformation.
                </p>
                <pre><code class="language-csharp">List&lt;object&gt; data = [
    new Employee { Name = "Alice", Department = "HR", Salary = 60000, Age = 30 },
    "Just a string",
    new Employee { Name = "Bob", Department = "IT", Salary = 75000, Age = 45 },
    null,
    new Employee { Name = "Charlie", Department = "Finance", Salary = 90000, Age = 55 },
    12345
];

// Property patterns in Where clause
var seniorHighEarners = data
    .OfType&lt;Employee&gt;() // First, get only Employee objects
    .Where(e => e is { Salary: >= 70000, Age: >= 40 }); // Property pattern matching

Console.WriteLine("Senior High Earners:");
foreach (var e in seniorHighEarners) {
    Console.WriteLine($"- {e.Name} (Age: {e.Age}, Salary: ${e.Salary})");
}

// Switch expression with patterns in Select
var dataDescriptions = data.Select(item => item switch {
    Employee { Salary: >= 90000 } e => $"Top Earner: {e.Name}",
    Employee { Department: "IT" } e => $"IT Staff: {e.Name}",
    Employee e => $"Other Employee: {e.Name}",
    string s when s.Length > 10 => $"Long String: '{s}'",
    string s => $"String: '{s}'",
    int i => $"Integer: {i}",
    null => "[NULL]",
    _ => $"Other Type: {item?.GetType().Name ?? "N/A"}"
});

Console.WriteLine("\nData Descriptions:");
foreach(var desc in dataDescriptions) {
    Console.WriteLine($"- {desc}");
}

// List patterns (Example: find sequences matching a pattern)
List&lt;int[]&gt; sequences = [ [1, 2, 3], [1, 99, 3], [4, 5, 6], [1, 2] ];

var sequencesStartingWithOneTwo = sequences
    .Where(seq => seq is [1, 2, ..]); // List pattern: starts with 1, 2

Console.WriteLine("\nSequences starting with [1, 2, ...]:");
foreach(var seq in sequencesStartingWithOneTwo) {
    Console.WriteLine($"- [{string.Join(", ", seq)}]");
}
</code></pre>
                <div class="code-result">
                    Senior High Earners:
                    - Bob (Age: 45, Salary: $75000)
                    - Charlie (Age: 55, Salary: $90000)

                    Data Descriptions:
                    - Other Employee: Alice
                    - String: 'Just a string'
                    - IT Staff: Bob
                    - [NULL]
                    - Top Earner: Charlie
                    - Integer: 12345

                    Sequences starting with [1, 2, ...]:
                    - [1, 2, 3]
                </div>

                <div class="note">
                    As C# evolves, keep an eye on how new features can simplify or enhance your LINQ queries. Features
                    that promote immutability (records), concise syntax (collection expressions, primary constructors),
                    and expressive logic (pattern matching) often fit very well with LINQ's declarative style.
                </div>
            </div>

            <div class="section">
                <h3 id="linq-to-sql" class="text-2xl font-semibold">Querying Databases with LINQ to Entities (EF Core)
                </h3>

                <p>
                    While the section ID mentions "LINQ to SQL", the modern and recommended way to query databases using
                    LINQ in .NET is via an Object-Relational Mapper (ORM) like **Entity Framework Core (EF Core)**. EF
                    Core allows you to write LINQ queries against your C# entity classes, and it translates those
                    queries into the appropriate database language (e.g., SQL).
                </p>
                <p>This provides strong typing, IntelliSense, compile-time checking, and abstracts away the underlying
                    database syntax.</p>

                <h4 class="text-xl font-medium mt-6">Entity Framework Core Setup Basics</h4>
                <p>Using EF Core involves three main parts:</p>
                <ol class="list-decimal pl-8 mb-4">
                    <li><strong>Define Entity Classes:</strong> Plain C# classes (POCOs) that map to your database
                        tables. (See example `Customer`, `Order` classes defined earlier).</li>
                    <li><strong>Define a `DbContext`:** A class that inherits from
                            `Microsoft.EntityFrameworkCore.DbContext`. It represents a session with the database and
                            contains `DbSet&lt;TEntity&gt;` properties for each entity you want to query. (See example
                            `ECommerceContext` defined earlier).</li>
                    <li><strong>Configure the Database Connection:** Typically done in the `DbContext`'s `OnConfiguring`
                            method or via dependency injection in application startup.</li>
                </ol>
                <div class="tip">
                    <strong>Installation:</strong> You'll need EF Core NuGet packages. For SQL Server, you typically
                    install:
                    <ul class="list-disc pl-4 mt-2">
                        <li>`Microsoft.EntityFrameworkCore.SqlServer`</li>
                        <li>`Microsoft.EntityFrameworkCore.Tools` (for migrations)</li>
                    </ul>
                    For the in-memory provider used in examples: `Microsoft.EntityFrameworkCore.InMemory`
                </div>

                <h4 class="text-xl font-medium mt-6">Writing LINQ to Entities Queries</h4>
                <p>You write LINQ queries against the `DbSet&lt;TEntity&gt;` properties on your `DbContext`. These
                    queries return `IQueryable&lt;TEntity&gt;`.</p>
                <pre><code class="language-csharp">public static class EfCoreQueries
{
    public static void RunQueries()
    {
        // DbContext should typically be short-lived, often scoped per web request or operation.
        // Using statement ensures it's disposed properly.
        using var context = new ECommerceContext();

        // Seed data if the in-memory database is empty
        if (!context.Customers.Any())
        {
            context.Customers.AddRange(
                new Customer { Id = 1, Name = "Alice", City = "New York", JoinDate = DateTime.Now.AddYears(-1), IsActive = true },
                new Customer { Id = 2, Name = "Bob", City = "Chicago", JoinDate = DateTime.Now.AddMonths(-6), IsActive = true },
                new Customer { Id = 3, Name = "Charlie", City = "New York", JoinDate = DateTime.Now.AddDays(-30), IsActive = false }
            );
            context.Orders.AddRange(
                new Order { Id = 101, CustomerId = 1, OrderDate = DateTime.Now.AddDays(-10), TotalAmount = 150.75m },
                new Order { Id = 102, CustomerId = 2, OrderDate = DateTime.Now.AddDays(-5), TotalAmount = 99.50m },
                new Order { Id = 103, CustomerId = 1, OrderDate = DateTime.Now.AddDays(-2), TotalAmount = 210.00m }
            );
            context.SaveChanges(); // Save changes to the database (or in-memory store)
        }

        // --- Basic Filtering (WHERE) ---
        Console.WriteLine("--- Customers from New York ---");
        var nyCustomers = context.Customers // IQueryable&lt;Customer&gt;
            .Where(c => c.City == "New York"); // Builds expression tree

        // Query is executed when enumerated (e.g., by ToList or foreach)
        foreach (var customer in nyCustomers.ToList()) // ToList executes SQL
        {
            Console.WriteLine($"- {customer.Name} (ID: {customer.Id})");
        }

        // --- Projection (SELECT) ---
        Console.WriteLine("\n--- Active Customer Names and Join Dates ---");
        var activeCustomerInfo = context.Customers
            .Where(c => c.IsActive)
            .Select(c => new { c.Name, c.JoinDate }); // Project to anonymous type

        foreach (var info in activeCustomerInfo.ToList()) // Executes SQL
        {
            Console.WriteLine($"- {info.Name}, Joined: {info.JoinDate:yyyy-MM-dd}");
        }

        // --- Ordering (ORDER BY) ---
        Console.WriteLine("\n--- Customers Ordered by Join Date (Oldest First) ---");
        var customersByJoinDate = context.Customers
            .OrderBy(c => c.JoinDate);

        foreach (var customer in customersByJoinDate.ToList()) // Executes SQL
        {
            Console.WriteLine($"- {customer.Name}, Joined: {customer.JoinDate:yyyy-MM-dd}");
        }

        // --- Aggregation (Executed Immediately) ---
        Console.WriteLine("\n--- Aggregates ---");
        int totalCustomerCount = context.Customers.Count(); // Executes SQL COUNT(*)
        decimal totalOrderAmount = context.Orders.Sum(o => o.TotalAmount); // Executes SQL SUM(TotalAmount)
        bool anyInactive = context.Customers.Any(c => !c.IsActive); // Executes SQL EXISTS(...)

        Console.WriteLine($"Total Customers: {totalCustomerCount}");
        Console.WriteLine($"Total Order Amount: ${totalOrderAmount:F2}");
        Console.WriteLine($"Any Inactive Customers? {anyInactive}");

        // --- Finding a Single Entity ---
        Console.WriteLine("\n--- Single Entity ---");
        // Find by primary key (optimized)
        Customer? customer1 = context.Customers.Find(1);
        Console.WriteLine($"Customer 1 (Find): {customer1?.Name ?? "Not Found"}");

        // Find using FirstOrDefault
        Customer? firstChicagoCustomer = context.Customers
                                            .FirstOrDefault(c => c.City == "Chicago"); // Executes SQL TOP(1) ... WHERE
        Console.WriteLine($"First Chicago Customer: {firstChicagoCustomer?.Name ?? "Not Found"}");
    }
}
// Call the method to run: EfCoreQueries.RunQueries();
</code></pre>
                <div class="code-result">
                    --- Customers from New York ---
                    - Alice (ID: 1)
                    - Charlie (ID: 3)

                    --- Active Customer Names and Join Dates ---
                    - Alice, Joined: 2023-05-18 <!-- Example Date -->
                    - Bob, Joined: 2023-11-18 <!-- Example Date -->

                    --- Customers Ordered by Join Date (Oldest First) ---
                    - Alice, Joined: 2023-05-18 <!-- Example Date -->
                    - Bob, Joined: 2023-11-18 <!-- Example Date -->
                    - Charlie, Joined: 2024-04-18 <!-- Example Date -->

                    --- Aggregates ---
                    Total Customers: 3
                    Total Order Amount: $460.25
                    Any Inactive Customers? True

                    --- Single Entity ---
                    Customer 1 (Find): Alice
                    First Chicago Customer: Bob
                </div>

                <h4 class="text-xl font-medium mt-6">Query Translation and Execution</h4>
                <p>
                    The power of LINQ to Entities lies in its ability to translate your C# LINQ expressions into
                    efficient database queries.
                </p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Server-Side Evaluation:</strong> As much of the query as possible (<code>Where</code>,
                        <code>OrderBy</code>, <code>Select</code>, <code>Join</code>, <code>GroupBy</code>, aggregates,
                        etc.) is translated into SQL and executed on the database server. This minimizes data transfer.
                    </li>
                    <li><strong>Client-Side Evaluation:</strong> Some LINQ methods or C# expressions within queries
                        cannot be translated to SQL (e.g., calling arbitrary C# methods, using certain .NET types). If
                        EF Core encounters such an expression *before* the query is materialized, it might throw an
                        exception or (in some cases) switch to client-side evaluation. Switching means it fetches more
                        data than necessary from the database and performs the remaining operations in your
                        application's memory. Use this sparingly and deliberately (often after an
                        <code>AsEnumerable()</code> call).
                    </li>
                </ul>
                <pre><code class="language-csharp">// Example showing translation
using var context = new ECommerceContext();
// Make sure context is seeded as before

IQueryable&lt;Customer&gt; query = context.Customers
    .Where(c => c.City == "New York" && c.Name.StartsWith("A"))
    .OrderBy(c => c.JoinDate)
    .Select(c => new { c.Id, c.Name }); // Only select Id and Name

// Get the generated SQL (EF Core 5+)
string sql = query.ToQueryString();
Console.WriteLine("--- Generated SQL ---");
Console.WriteLine(sql);

// Execute the query
var results = query.ToList();

// Example of potential client-side evaluation (avoid if possible)
string GetCityCode(string cityName) => cityName.Substring(0, 2).ToUpper();

// This Where clause calls a C# method EF Core likely cannot translate
// var clientEvalQuery = context.Customers
//    .Where(c => GetCityCode(c.City) == "NE"); // May throw exception or fetch all data

// Better: Perform translatable operations first
var betterQuery = context.Customers
    .Where(c => c.City == "New York") // Translatable
    .AsEnumerable() // Switch to client-side intentionally
    .Where(c => GetCityCode(c.City) == "NE"); // Now runs in memory on NY customers only
</code></pre>
                <div class="code-result">
                    --- Generated SQL ---
                    -- SQL will vary slightly based on EF Core version and provider, but conceptually:
                    SELECT [c].[Id], [c].[Name]
                    FROM [Customers] AS [c]
                    WHERE ([c].[City] = N'New York') AND ([c].[Name] LIKE N'A%')
                    ORDER BY [c].[JoinDate]
                </div>

                <h4 class="text-xl font-medium mt-6">Loading Related Data</h4>
                <p>When querying an entity, EF Core doesn't automatically load its related entities (navigation
                    properties). You need to explicitly tell it how to load them:</p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Eager Loading (`Include`, `ThenInclude`):</strong> Loads related data along with the
                        main query using JOINs in SQL. Best for when you know you'll need the related data.</li>
                    <li><strong>Explicit Loading (`Load`):</strong> Loads related data for an already fetched entity on
                        demand. Requires a separate database query.</li>
                    <li><strong>Lazy Loading (Requires configuration):</strong> Related data is automatically loaded
                        from the database the first time a navigation property is accessed. Convenient but can lead to
                        the N+1 query problem if not used carefully. Requires installing
                        `Microsoft.EntityFrameworkCore.Proxies` and enabling it.</li>
                </ul>
                <pre><code class="language-csharp">using var context = new ECommerceContext();
// Make sure context is seeded as before

// --- Eager Loading ---
Console.WriteLine("--- Eager Loading (Customers with Orders) ---");
var customersWithOrders = context.Customers
    .Include(c => c.OrderList) // Include the Orders navigation property
    .Where(c => c.City == "New York")
    .ToList(); // Executes SQL with JOIN

foreach (var customer in customersWithOrders)
{
    Console.WriteLine($"- Customer: {customer.Name}");
    foreach (var order in customer.OrderList) // Access related data loaded eagerly
    {
        Console.WriteLine($"  Order {order.Id}, Amount: ${order.TotalAmount}");
    }
     if (!customer.OrderList.Any()) Console.WriteLine("  (No orders)");
}

// --- Explicit Loading ---
Console.WriteLine("\n--- Explicit Loading ---");
var customerBob = context.Customers.FirstOrDefault(c => c.Name == "Bob");
if (customerBob != null)
{
    Console.WriteLine($"Fetched Bob. Orders loaded? {context.Entry(customerBob).Collection(c => c.OrderList).IsLoaded}");
    // Load Bob's orders explicitly
    context.Entry(customerBob).Collection(c => c.OrderList).Load(); // Executes separate SQL query
    Console.WriteLine($"Orders loaded now? {context.Entry(customerBob).Collection(c => c.OrderList).IsLoaded}");
    foreach (var order in customerBob.OrderList)
    {
        Console.WriteLine($"  Order {order.Id}, Amount: ${order.TotalAmount}");
    }
}

// --- Lazy Loading (Conceptual - requires setup not shown here) ---
// Console.WriteLine("\n--- Lazy Loading (Conceptual) ---");
// var customerAliceLazy = context.Customers.Find(1); // Assuming lazy loading is configured
// Console.WriteLine($"Fetched Alice (Lazy). Accessing Orders...");
// foreach (var order in customerAliceLazy.Orders) // Accessing Orders triggers DB query automatically
// {
//    Console.WriteLine($"  Order {order.Id}, Amount: ${order.TotalAmount}");
// }
</code></pre>
                <div class="code-result">
                    --- Eager Loading (Customers with Orders) ---
                    - Customer: Alice
                    Order 101, Amount: $150.75
                    Order 103, Amount: $210.00
                    - Customer: Charlie
                    (No orders) <!-- Assuming Charlie has no orders in seeded data -->

                    --- Explicit Loading ---
                    Fetched Bob. Orders loaded? False
                    Orders loaded now? True
                    Order 102, Amount: $99.50
                </div>

                <h4 class="text-xl font-medium mt-6">Performance Considerations (`AsNoTracking`, `AsSplitQuery`)</h4>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Change Tracking:</strong> By default, EF Core tracks changes to entities it fetches.
                        This allows you to modify entities and call `SaveChanges()` easily. However, tracking has
                        overhead.</li>
                    <li><strong>`AsNoTracking()`:</strong> For read-only queries where you won't be updating the fetched
                        data, use `AsNoTracking()`. EF Core skips the tracking setup, making the query faster and use
                        less memory.</li>
                    <li><strong>Cartesian Explosion:</strong> When using `Include` for multiple one-to-many or
                        many-to-many relationships, the generated SQL JOIN can return a lot of duplicated data, leading
                        to performance issues (Cartesian explosion).</li>
                    <li><strong>`AsSplitQuery()`:</strong> Tells EF Core to generate multiple separate SQL queries
                        instead of one large JOIN when loading related collections via `Include`. This avoids the
                        Cartesian explosion problem but results in multiple database round trips. Use it when including
                        multiple collections.</li>
                </ul>
                <pre><code class="language-csharp">using var context = new ECommerceContext();
// Make sure context is seeded as before

// Read-only query - Use AsNoTracking()
var readOnlyCustomers = context.Customers
    .AsNoTracking() // Improves performance for read-only scenarios
    .Where(c => c.IsActive)
    .ToList();

// Query including multiple collections - Use AsSplitQuery()
var customersAndOrdersAndItems = context.Customers
    .Include(c => c.OrderList)       // Include first collection
    // .ThenInclude(o => o.Items) // Assuming Order has OrderItems collection
    .Where(c => c.Id == 1)
    .AsSplitQuery() // Generates separate SQL queries for Customers, Orders, Items
    .FirstOrDefault();
</code></pre>
                <div class="warning">Always profile your database queries! Use tools like SQL Server Profiler, EF Core
                    logging, or third-party tools (MiniProfiler, Application Insights) to understand the generated SQL
                    and identify performance bottlenecks. Optimize your LINQ queries based on profiling data.</div>
            </div>

            <div class="section">
                <h3 id="custom-operators" class="text-2xl font-semibold">Custom LINQ Operators</h3>

                <p>
                    While LINQ provides a vast array of standard query operators, you might encounter scenarios
                    requiring specialized logic not covered by the built-in methods. You can extend LINQ by creating
                    your own custom operators using C# extension methods.
                </p>

                <h4 class="text-xl font-medium mt-6">Creating Reusable Extension Methods for `IEnumerable<T>`</h4>
                <p>
                    Custom LINQ operators are static methods within a static class that extend the
                    <code>IEnumerable&lt;T&gt;</code> interface (or <code>IQueryable&lt;T&gt;</code> for database
                    providers, which is more complex). They should ideally follow LINQ principles like deferred
                    execution.
                </p>

                <h5 class="text-lg font-medium mt-4">Example: `Shuffle` Operator</h5>
                <p>Let's create an operator to randomly shuffle the elements of a sequence.</p>
                <pre><code class="language-csharp">public static class LinqExtensions
{
    private static Random _random = new Random();

    // Custom Shuffle operator for IEnumerable&lt;T&gt;
    // Note: This operator necessarily buffers the source sequence
    public static IEnumerable&lt;T&gt; Shuffle&lt;T&gt;(this IEnumerable&lt;T&gt; source)
    {
        if (source == null) throw new ArgumentNullException(nameof(source));

        // Materialize the source to allow random access and shuffling
        var buffered = source.ToList();
        int n = buffered.Count;
        while (n > 1)
        {
            n--;
            int k = _random.Next(n + 1);
            // Swap elements
            T value = buffered[k];
            buffered[k] = buffered[n];
            buffered[n] = value;
        }
        // Return the shuffled list (could also use yield return here if preferred)
        return buffered;
    }

    // Custom operator: WithIndex (adds index to each element) - Deferred Execution
    public static IEnumerable&lt;(T item, int index)&gt; WithIndex&lt;T&gt;(
        this IEnumerable&lt;T&gt; source)
    {
        if (source == null) throw new ArgumentNullException(nameof(source));

        return source.Select((item, index) => (item, index)); // Using built-in Select overload
        // Or implementation using yield return:
        // int index = 0;
        // foreach (var item in source)
        // {
        //     yield return (item, index++);
        // }
    }

    // Custom operator: Log (logs each item as it passes through - Deferred)
    public static IEnumerable&lt;T&gt; Log&lt;T&gt;(this IEnumerable&lt;T&gt; source, string prefix = "LOG")
    {
        if (source == null) throw new ArgumentNullException(nameof(source));

        return source.Select(item => {
            Console.WriteLine($"[{prefix}]: {item}");
            return item;
        });
        // Or implementation using yield return:
        // foreach(var item in source)
        // {
        //     Console.WriteLine($"[{prefix}]: {item}");
        //     yield return item;
        // }
    }
}
</code></pre>

                <h5 class="text-lg font-medium mt-4">Using the Custom Operators</h5>
                <pre><code class="language-csharp">List&lt;string&gt; cards = ["Ace", "King", "Queen", "Jack", "10"];

Console.WriteLine("Original Deck: " + string.Join(", ", cards));

// Use the custom Shuffle operator
var shuffledDeck = cards.Shuffle();
Console.WriteLine("Shuffled Deck: " + string.Join(", ", shuffledDeck));

// Use WithIndex
Console.WriteLine("\nCards with Index:");
foreach (var (card, index) in cards.WithIndex())
{
    Console.WriteLine($"- Index {index}: {card}");
}

// Combine custom and standard operators (demonstrates deferred execution of Log)
Console.WriteLine("\nProcessing pipeline with Log:");
var processedCards = cards
    .Log("Start") // Log each card at the start
    .Where(card => card.Length > 4)
    .Log("After Where") // Log only cards that passed the filter
    .OrderBy(card => card)
    .Log("After OrderBy") // Log the sorted, filtered cards
    .Select(card => card.ToUpper())
    .Log("After Select") // Log the final result
    .ToList(); // Execute the pipeline

Console.WriteLine("\nFinal Processed Cards: " + string.Join(", ", processedCards));
</code></pre>
                <div class="code-result">
                    Original Deck: Ace, King, Queen, Jack, 10
                    Shuffled Deck: Queen, Jack, Ace, 10, King <!-- Example Shuffle Output -->

                    Cards with Index:
                    - Index 0: Ace
                    - Index 1: King
                    - Index 2: Queen
                    - Index 3: Jack
                    - Index 4: 10

                    Processing pipeline with Log:
                    [Start]: Ace
                    [Start]: King
                    [After Where]: King
                    [Start]: Queen
                    [After Where]: Queen
                    [Start]: Jack
                    [Start]: 10
                    [After OrderBy]: King
                    [After Select]: KING
                    [After OrderBy]: Queen
                    [After Select]: QUEEN

                    Final Processed Cards: KING, QUEEN
                </div>

                <h4 class="text-xl font-medium mt-6">Design Considerations for Custom Operators</h4>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Deferred Execution:</strong> Whenever possible, implement custom operators using
                        <code>yield return</code> or by composing existing deferred operators (like <code>Select</code>,
                        <code>Where</code>). This preserves the lazy evaluation nature of LINQ. Operators that require
                        iterating the whole sequence (like sorting or shuffling) inherently cannot be fully deferred but
                        should still defer their execution until enumerated.
                    </li>
                    <li><strong>Immutability:</strong> Operators should not modify the source collection. They should
                        return a new <code>IEnumerable&lt;T&gt;</code> representing the result of the operation.</li>
                    <li><strong>Parameter Validation:</strong> Check for null arguments (especially the source sequence)
                        and throw appropriate exceptions (<code>ArgumentNullException</code>).</li>
                    <li><strong>Clarity and Purpose:</strong> Create operators that perform a well-defined,
                        understandable task. Avoid creating overly complex "mega-operators".</li>
                    <li><strong>Naming Conventions:</strong> Follow existing LINQ naming patterns where applicable.</li>
                </ul>

                <h4 class="text-xl font-medium mt-6">Integrating Third-Party LINQ Libraries (e.g., MoreLINQ)</h4>
                <p>
                    Instead of writing every custom operator yourself, consider using well-established libraries like
                    MoreLINQ, which provides a rich set of useful extensions.
                </p>
                <pre><code class="language-csharp">// First, install the MoreLINQ NuGet package:
// PM> Install-Package morelinq

using MoreLinq; // Bring MoreLINQ extension methods into scope
using MoreLinq.Extensions; // Some extensions might be here

public static class MoreLinqExamples
{
    public static void Run()
    {
        List&lt;Product&gt; products = ExampleData.GetProducts();
        List&lt;int&gt; numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        // Batch: Process items in batches (similar to Chunk in .NET 6+)
        Console.WriteLine("--- Batch ---");
        foreach (var batch in numbers.Batch(3))
        {
            Console.WriteLine($"Processing batch: {string.Join(", ", batch)}");
        }

        // Pipe: Perform an action on each element without altering the sequence (like our Log)
        Console.WriteLine("\n--- Pipe ---");
        var processed = numbers.Pipe(n => Console.WriteLine($"Piping: {n}")).ToList();

        // DistinctBy: Get distinct elements based on a key selector (now built-in in .NET 6+)
        Console.WriteLine("\n--- DistinctBy (Category) ---");
        var distinctByCategory = products.DistinctBy(p => p.Category);
        Console.WriteLine(string.Join(", ", distinctByCategory.Select(p => p.Name)));

        // MaxBy / MinBy: Find element with max/min value based on a selector (now built-in in .NET 6+)
        Console.WriteLine("\n--- MaxBy / MinBy (Price) ---");
        var mostExpensive = products.MaxBy(p => p.Price).First(); // MaxBy returns IEnumerable
        var leastExpensive = products.MinBy(p => p.Price).First(); // MinBy returns IEnumerable
        Console.WriteLine($"Most Expensive: {mostExpensive.Name} (${mostExpensive.Price})");
        Console.WriteLine($"Least Expensive: {leastExpensive.Name} (${leastExpensive.Price})");

        // Prepend / Append: Add elements to the start/end of a sequence
        Console.WriteLine("\n--- Prepend / Append ---");
        var extendedNumbers = numbers.Prepend(0).Append(11);
        Console.WriteLine(string.Join(", ", extendedNumbers));

        // Interleave: Combine two sequences by alternating elements
        Console.WriteLine("\n--- Interleave ---");
        var listA = ["A", "B", "C"];
        var listB = ["X", "Y", "Z", "W"]; // Different length
        var interleaved = listA.Interleave(listB);
        Console.WriteLine(string.Join(", ", interleaved)); // A, X, B, Y, C, Z, W
    }
}
    </code></pre>
                <h4 class="text-xl font-medium mt-6">Understanding IQueryable vs IEnumerable</h4>
                <pre><code class="language-csharp">var queryableProducts = context.Products
    .Where(p => p.Category == "Electronics"); // IQueryable - expression tree

    var enumerableProducts = context.Products
        .Where(p => p.Category == "Electronics")
        .AsEnumerable(); // Switches to IEnumerable - further ops run in memory

    // This Where clause runs efficiently on the DB via IQueryable
    var dbFiltered = queryableProducts.Where(p => p.Price > 500);

    // This Where clause runs in application memory on ALL electronics products
    // because AsEnumerable() was called earlier. Potentially inefficient.
    var memoryFiltered = enumerableProducts.Where(p => p.Price > 500);

    // Takeaway: Keep queries as IQueryable as long as possible to leverage
    // the database query optimizer. Use AsEnumerable() only when necessary
    // to perform operations not translatable to SQL, ideally after filtering.
</code></pre>

                <h5 class="text-lg font-medium mt-4">Database Context Example</h5>
                <pre><code class="language-csharp">// Dummy context for the IQueryable example
public class ProductContext : Microsoft.EntityFrameworkCore.DbContext
{
    public Microsoft.EntityFrameworkCore.DbSet<Product> Products { get; set; } = null!;

    protected override void OnConfiguring(Microsoft.EntityFrameworkCore.DbContextOptionsBuilder optionsBuilder)
        => optionsBuilder.UseInMemoryDatabase("ProductDbExample");
}</code></pre>

                <h5 class="text-lg font-medium mt-4">Leveraging `Span<T>` and `Memory<T>` (Advanced)</h5>
                <p>For high-performance scenarios involving array or string processing within LINQ (usually
                    after materialization or on specific sources), using <code>Span<T></code> or
                    <code>Memory<T></code> can help avoid unnecessary allocations.
                </p>
                <pre><code class="language-csharp">string dataLine = "ID=123,Name=Widget,Price=45.67,Category=Widgets";

// Avoid multiple string allocations with Span<char>
ReadOnlySpan<char> lineSpan = dataLine.AsSpan();

// Custom parsing logic using spans (more complex but potentially lower allocation)
(string id, string name, decimal price) ParseLine(ReadOnlySpan<char> span)
{
    // Simplified parsing logic - real code would be more robust
    var idPart = span.Slice(span.IndexOf('=') + 1, span.IndexOf(',') - span.IndexOf('=') - 1);
    span = span.Slice(span.IndexOf(',') + 1); // Move past first part
    var namePart = span.Slice(span.IndexOf('=') + 1, span.IndexOf(',') - span.IndexOf('=') - 1);
    span = span.Slice(span.IndexOf(',') + 1);
    var pricePart = span.Slice(span.IndexOf('=') + 1, span.IndexOf(',') - span.IndexOf('=') - 1);

    return (
        idPart.ToString(), // Allocation happens here when converting back
        namePart.ToString(),
        decimal.Parse(pricePart)
    );
}

var parsedData = ParseLine(lineSpan);
Console.WriteLine($"Parsed with Span: ID={parsedData.id}, Name={parsedData.name}, Price={parsedData.price}");

// Note: LINQ itself doesn't directly operate on Spans extensively,
// but Spans can be used within the processing logic called by LINQ operators
// or when processing data sources that yield Spans/Memory.
</code></pre>
                <div class="code-result">
                    Parsed with Span: ID=123, Name=Widget, Price=45.67
                </div>

                <h4 class="text-xl font-medium mt-6">Profiling LINQ Queries</h4>
                <p>Identifying performance bottlenecks requires profiling:</p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Benchmarking Tools:</strong> Use <code>BenchmarkDotNet</code> (shown earlier)
                        for micro-benchmarking specific LINQ operations on in-memory data.</li>
                    <li><strong>Database Profiling Tools:</strong>
                        <ul>
                            <li><strong>SQL Server Profiler/Extended Events:</strong> Monitor the exact SQL
                                queries generated by LINQ to Entities/SQL hitting your SQL Server database.
                                Analyze query plans, execution times, and resource usage.</li>
                            <li><strong>EF Core Logging:</strong> Configure EF Core to log generated SQL queries
                                to the console, debug output, or a file. Useful during development.</li>
                        </ul>
                    </li>
                    <li><strong>Application Performance Monitoring (APM):</strong> Tools like Application
                        Insights, Datadog, or Dynatrace can monitor application performance in production, often
                        highlighting slow database queries originating from LINQ.</li>
                    <li><strong>Visual Studio Diagnostic Tools:</strong> The built-in profiler can help identify
                        CPU usage and memory allocation hotspots, which might point to inefficient LINQ
                        operations.</li>
                </ul>
                <pre><code class="language-csharp">// Example: Enabling Basic EF Core Logging (in OnConfiguring)
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseInMemoryDatabase("ProductDbExample") // Or UseSqlServer(...)
        .LogTo(Console.WriteLine, Microsoft.Extensions.Logging.LogLevel.Information) // Log SQL and other info
        .EnableSensitiveDataLogging(); // Include parameter values (use only in development)
}

// When you run queries using a context configured like this, EF Core
// will print the generated SQL and other diagnostic information to the console.
</code></pre>

                <div class="tip"><strong>Profiling Focus:</strong> When profiling LINQ, pay attention to:
                    execution time, number of database queries (for LINQ to Entities), amount of data
                    transferred, CPU usage, and memory allocations (especially from materialization or
                    inefficient projections).</div>
            </div>

            <div class="section">
                <h3 id="real-world" class="text-2xl font-semibold">LINQ in Real-World Applications</h3>

                <p>
                    LINQ is not just an academic feature; it's a workhorse in modern .NET development, used across
                    various application types and layers for data manipulation, transformation, and querying.
                </p>

                <h4 class="text-xl font-medium mt-6">Data Transformation and ETL (Extract, Transform, Load)</h4>
                <p>LINQ is excellent for reading data from one source, transforming it into a desired format, and
                    preparing it for loading into another system or for display.</p>
                <pre><code class="language-csharp">// Scenario: Read CSV data, clean it, transform it, and prepare for import.

        // Simulate reading lines from a CSV file
        IEnumerable<string> ReadCsvLines(string filePath)
        {
            // In reality: yield return File.ReadLines(filePath);
            yield return "ProductID,ProductName, Price , Stock Status "; // Header
            yield return "101,Super Widget, 19.99, In Stock";
            yield return "102,Mega Gadget, 45.50, Low Stock";
            yield return "103,Basic Thing, 9.00, Out of Stock";
            yield return " , Invalid Data,,"; // Bad line
            yield return "105,Another Item, 15.00, In Stock";
        }

        public record ProductImportDto(int Id, string Name, decimal Price, bool IsAvailable);

        // LINQ pipeline for ETL
        string csvFilePath = "dummy.csv";
        List<ProductImportDto> productsToImport = ReadCsvLines(csvFilePath)
            .Skip(1) // Skip header row
            .Select(line => line.Split(',')) // Split into fields
            .Where(fields => fields.Length == 4 && !fields.Any(string.IsNullOrWhiteSpace)) // Basic validation
            .Select(fields => new { // Intermediate anonymous type for parsing
                IdString = fields[0].Trim(),
                Name = fields[1].Trim(),
                PriceString = fields[2].Trim(),
                Status = fields[3].Trim()
            })
            .Where(parsed => int.TryParse(parsed.IdString, out _) && decimal.TryParse(parsed.PriceString, out _)) // Stronger validation
            .Select(valid => new ProductImportDto( // Final transformation to DTO
                int.Parse(valid.IdString),
                valid.Name,
                decimal.Parse(valid.PriceString),
                valid.Status.Equals("In Stock", StringComparison.OrdinalIgnoreCase) ||
                valid.Status.Equals("Low Stock", StringComparison.OrdinalIgnoreCase)
            ))
            .Where(dto => dto.Price > 0) // Business rule: Price must be positive
            .OrderBy(dto => dto.Name)
            .ToList(); // Materialize the final list ready for import

        Console.WriteLine("--- Products Ready for Import ---");
        foreach (var dto in productsToImport)
        {
            Console.WriteLine($"ID: {dto.Id}, Name: {dto.Name}, Price: {dto.Price}, Available: {dto.IsAvailable}");
        }
        </code></pre>
                <div class="code-result">
                    --- Products Ready for Import ---
                    ID: 105, Name: Another Item, Price: 15.00, Available: True
                    ID: 103, Name: Basic Thing, Price: 9.00, Available: False
                    ID: 102, Name: Mega Gadget, Price: 45.50, Available: True
                    ID: 101, Name: Super Widget, Price: 19.99, Available: True
                </div>

                <h4 class="text-xl font-medium mt-6">Implementing Business Logic</h4>
                <p>LINQ helps express complex business rules and data filtering concisely within application logic.
                </p>
                <pre><code class="language-csharp">// Scenario: Find customers eligible for a special promotion
        // Rule: Active customers in specific cities who have placed at least 2 orders > $50 in the last 90 days.

        List<Customer> allCustomers = GetSampleCustomersWithOrders(); // Assume this gets detailed customer data
        List<string> eligibleCities = ["New York", "Chicago"];
        DateTime ninetyDaysAgo = DateTime.Now.AddDays(-90);

        var eligibleCustomers = allCustomers
            .Where(c => c.IsActive) // Rule: Must be active
            .Where(c => eligibleCities.Contains(c.City)) // Rule: Must be in eligible city
            .Where(c => c.OrderList.Count( // Rule: Count orders meeting criteria
                            order => order.OrderDate >= ninetyDaysAgo && order.TotalAmount > 50m
                         ) >= 2)
            .Select(c => new { c.Name, c.Email }) // Select info needed for notification
            .ToList();

        Console.WriteLine("\n--- Customers Eligible for Promotion ---");
        foreach (var customer in eligibleCustomers)
        {
            Console.WriteLine($"- Name: {customer.Name}, Email: {customer.Email}");
        }

        // Helper to simulate data
        static List<Customer> GetSampleCustomersWithOrders() {
            return [
                new Customer { Id = 1, Name = "Alice", City = "New York", IsActive = true, OrderList = [ new Order { Id=1, OrderDate=DateTime.Now.AddDays(-10), TotalAmount=60m}, new Order { Id=2, OrderDate=DateTime.Now.AddDays(-20), TotalAmount=75m}, new Order { Id=3, OrderDate=DateTime.Now.AddDays(-100), TotalAmount=100m} ]},
                new Customer { Id = 2, Name = "Bob", City = "Chicago", IsActive = true, OrderList = [ new Order { Id=4, OrderDate=DateTime.Now.AddDays(-5), TotalAmount=100m} ]}, // Only 1 recent order > 50
                new Customer { Id = 3, Name = "Charlie", City = "New York", IsActive = false, OrderList = [ new Order { Id=5, OrderDate=DateTime.Now.AddDays(-15), TotalAmount=80m}, new Order { Id=6, OrderDate=DateTime.Now.AddDays(-25), TotalAmount=90m} ]}, // Inactive
                new Customer { Id = 4, Name = "David", City = "Seattle", IsActive = true, OrderList = [ new Order { Id=7, OrderDate=DateTime.Now.AddDays(-12), TotalAmount=65m}, new Order { Id=8, OrderDate=DateTime.Now.AddDays(-22), TotalAmount=70m} ]}, // Wrong city
                new Customer { Id = 5, Name = "Eve", City = "Chicago", IsActive = true, OrderList = [ new Order { Id=9, OrderDate=DateTime.Now.AddDays(-18), TotalAmount=55m}, new Order { Id=10, OrderDate=DateTime.Now.AddDays(-28), TotalAmount=40m}, new Order { Id=11, OrderDate=DateTime.Now.AddDays(-38), TotalAmount=85m} ]} // One order too small, one meets criteria
            ];
        }
        </code></pre>
                <div class="code-result">
                    --- Customers Eligible for Promotion ---
                    - Name: Alice, Email: <!-- Email would be here -->
                    - Name: Eve, Email: <!-- Email would be here -->
                </div>

                <h4 class="text-xl font-medium mt-6">API Data Shaping and Filtering</h4>
                <p>In web APIs, LINQ allows clients to request specific fields, filtering, and sorting, which can be
                    applied server-side (often using libraries that help parse query string parameters into LINQ
                    expressions).</p>
                <pre><code class="language-csharp">// Scenario: Simulate an API endpoint returning product data
        // Parameters might come from query string: ?fields=id,name&category=Electronics&sort=priceDesc

        // Simulated input parameters
        string? fields = "id,name,price";
        string? categoryFilter = "Electronics";
        string? sortOrder = "priceDesc";

        IQueryable<Product> query = ExampleData.GetProducts().AsQueryable(); // Start with base queryable

        // Apply filtering
        if (!string.IsNullOrEmpty(categoryFilter))
        {
            query = query.Where(p => p.Category == categoryFilter);
        }

        // Apply sorting (more robust parsing needed in real API)
        if (sortOrder == "priceDesc")
        {
            query = query.OrderByDescending(p => p.Price);
        }
        else if (sortOrder == "nameAsc")
        {
            query = query.OrderBy(p => p.Name);
        }
        // Add more sort options...

        // Apply projection/shaping (simplified example - libraries like OData help)
        // This part is complex to do dynamically and safely. Usually involves expression trees.
        // For simplicity, we'll just show selecting all fields based on the query so far.
        var results = query.ToList(); // Execute query

        // Manually shape based on 'fields' (demonstration only - not robust/secure)
        List<Dictionary<string, object>> shapedResults = new();
        if (!string.IsNullOrEmpty(fields)) {
            var requestedFields = fields.Split(',').Select(f => f.Trim().ToLowerInvariant()).ToHashSet();
            foreach(var product in results) {
                var shapedProduct = new Dictionary<string, object>();
                if (requestedFields.Contains("id")) shapedProduct["id"] = product.Id;
                if (requestedFields.Contains("name")) shapedProduct["name"] = product.Name;
                if (requestedFields.Contains("price")) shapedProduct["price"] = product.Price;
                if (requestedFields.Contains("category")) shapedProduct["category"] = product.Category;
                shapedResults.Add(shapedProduct);
            }
        } else {
             // Default shaping if no fields specified (or handle differently)
             shapedResults = results.Select(p => new Dictionary<string, object> {
                {"id", p.Id}, {"name", p.Name}, {"price", p.Price}, {"category", p.Category}
             }).ToList();
        }


        Console.WriteLine($"\n--- API Shaped Results (Filter: {categoryFilter}, Sort: {sortOrder}, Fields: {fields}) ---");
        foreach (var shapedProduct in shapedResults)
        {
            Console.WriteLine($"- {System.Text.Json.JsonSerializer.Serialize(shapedProduct)}");
        }

        </code></pre>
                <div class="code-result">
                    --- API Shaped Results (Filter: Electronics, Sort: priceDesc, Fields: id,name,price) ---
                    - {"id":1,"name":"Laptop","price":1200}
                    - {"id":3,"name":"Smartphone","price":800} <!-- Assuming Smartphone added to ExampleData -->
                    - {"id":5,"name":"Keyboard","price":75}
                    - {"id":2,"name":"Mouse","price":25}
                </div>
                <div class="note">Libraries like OData (Open Data Protocol) or custom implementations using
                    expression trees are typically used in real APIs to safely translate client query parameters
                    (like <code>$filter</code>, <code>$orderby</code>, <code>$select</code>) into LINQ expressions
                    executed against <code>IQueryable</code> sources like EF Core, preventing security issues and
                    simplifying implementation.</div>

                <h4 class="text-xl font-medium mt-6">Reporting and Aggregation</h4>
                <p>LINQ's grouping and aggregation functions are perfect for generating summary reports from raw
                    data.</p>
                <pre><code class="language-csharp">// Scenario: Generate a sales summary report by region and category
        List<Sale> salesData = ExampleData.sales; // Use previous Sale data

        var salesReport = salesData
            .GroupBy(s => new { s.Region, s.Category }) // Group by composite key
            .Select(g => new {
                g.Key.Region,
                g.Key.Category,
                TotalAmount = g.Sum(s => s.Amount),
                NumberOfSales = g.Count(),
                AverageSale = g.Average(s => s.Amount)
            })
            .OrderBy(r => r.Region) // Order report rows
            .ThenBy(r => r.Category)
            .ToList(); // Materialize the report data

        Console.WriteLine("\n--- Sales Summary Report ---");
        Console.WriteLine("| Region | Category    | Num Sales | Avg Sale | Total Amount |");
        Console.WriteLine("|--------|-------------|-----------|----------|--------------|");
        foreach (var reportLine in salesReport)
        {
            Console.WriteLine($"| {reportLine.Region,-6} | {reportLine.Category,-11} | {reportLine.NumberOfSales,9} | {reportLine.AverageSale,8:F2} | {reportLine.TotalAmount,12:F2} |");
        }
        </code></pre>
                <div class="code-result">
                    --- Sales Summary Report ---
                    | Region | Category | Num Sales | Avg Sale | Total Amount |
                    |--------|-------------|-----------|----------|--------------|
                    | East | Clothing | 1 | 250.00 | 250.00 |
                    | North | Electronics | 2 | 750.00 | 1500.00 |
                    | North | Furniture | 1 | 1200.00 | 1200.00 |
                    | South | Electronics | 1 | 800.00 | 800.00 |
                    | South | Furniture | 1 | 750.00 | 750.00 |
                    | West | Clothing | 1 | 300.00 | 300.00 |
                </div>
            </div>

            <div class="section">
                <h3 id="future" class="text-2xl font-semibold">Future of LINQ in C#</h3>

                <p>
                    LINQ remains a cornerstone of data manipulation in .NET. While the core concepts are stable, its
                    integration with new C# features and asynchronous programming continues to evolve.
                </p>

                <h4 class="text-xl font-medium mt-6">Integration with Async Streams (`IAsyncEnumerable<T>`)</h4>
                <p>
                    Introduced in C# 8.0 and .NET Core 3.0, asynchronous streams allow you to work with sequences of
                    data that are generated asynchronously (e.g., data streamed from a network service, database
                    results fetched incrementally). LINQ operators have asynchronous counterparts for
                    <code>IAsyncEnumerable<T></code>, primarily available through the <code>System.Linq.Async</code>
                    NuGet package or built into EF Core for async database queries.
                </p>
                <pre><code class="language-csharp">// Requires NuGet package: System.Linq.Async
        // Or use directly with EF Core async methods

        // Simulate an async data source
        async IAsyncEnumerable<int> GetNumbersAsync()
        {
            for (int i = 0; i < 10; i++)
            {
                await Task.Delay(100); // Simulate async work (e.g., network latency)
                yield return i;
            }
        }

        public static async Task ProcessAsyncStreams()
        {
            Console.WriteLine("\n--- Processing Async Stream ---");
            // Use await foreach to consume the async stream
            await foreach (var number in GetNumbersAsync()
                                .WhereAwait(async n => { // Async predicate
                                    await Task.Delay(10); // Simulate async check
                                    return n % 2 == 0;
                                 })
                                .SelectAwait(async n => { // Async projection
                                    await Task.Delay(5); // Simulate async transform
                                    return $"Number: {n}";
                                 }))
            {
                Console.WriteLine(number);
            }

            // Async aggregation (e.g., using System.Linq.Async package)
            // int count = await GetNumbersAsync().CountAsync();
            // Console.WriteLine($"Async Count: {count}");

            // EF Core provides async versions directly
            using var context = new ECommerceContext();
            // Seed if empty
            if (!await context.Customers.AnyAsync()) {
                context.Customers.AddRange(GetSampleCustomersWithOrders());
                await context.SaveChangesAsync();
            }

            Console.WriteLine("\n--- EF Core Async ---");
            List<string> activeNames = await context.Customers
                .Where(c => c.IsActive)
                .OrderBy(c => c.Name)
                .Select(c => c.Name)
                .ToListAsync(); // Async materialization

            Console.WriteLine("Active Customer Names (Async): " + string.Join(", ", activeNames));

            int nyCount = await context.Customers.CountAsync(c => c.City == "New York"); // Async Count
            Console.WriteLine($"NY Customer Count (Async): {nyCount}");
        }

        // To run: await FutureExamples.ProcessAsyncStreams(); (in an async main method)
        </code></pre>
                <div class="code-result">
                    --- Processing Async Stream ---
                    Number: 0
                    Number: 2
                    Number: 4
                    Number: 6
                    Number: 8

                    --- EF Core Async ---
                    Active Customer Names (Async): Alice, Bob, David, Eve
                    NY Customer Count (Async): 2
                </div>
                <p>Asynchronous LINQ is crucial for building responsive and scalable applications, especially those
                    involving I/O operations.</p>

                <h4 class="text-xl font-medium mt-6">Potential Language Enhancements (Speculative)</h4>
                <p>Future versions of C# might introduce features that further enhance LINQ:</p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>More Concise Lambdas:</strong> Further syntax improvements for simple lambda
                        expressions.</li>
                    <li><strong>Enhanced Pattern Matching in Queries:</strong> Direct support for more complex
                        patterns within query syntax clauses.</li>
                    <li><strong>Improved `IQueryable` Extensibility:</strong> Making it easier for third-party
                        providers to translate more C# features or custom methods to their native query languages.
                    </li>
                    <li><strong>Optimizations:</strong> Continued compiler and runtime optimizations for common LINQ
                        patterns.</li>
                    <li><strong>Data-Oriented Features:</strong> Potential language features focused on efficient
                        processing of structured data could influence LINQ usage.</li>
                </ul>

                <h4 class="text-xl font-medium mt-6">Role in Modern .NET</h4>
                <p>LINQ remains highly relevant:</p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Cloud Applications:</strong> Essential for querying databases (EF Core) and
                        processing data streams in web APIs and microservices.</li>
                    <li><strong>Data Science and ML.NET:</strong> Used for data loading, preparation, and
                        transformation steps in machine learning workflows.</li>
                    <li><strong>Cross-Platform Development (MAUI, Blazor):</strong> Used in application logic layers
                        for data handling regardless of the UI framework.</li>
                    <li><strong>Foundation for Higher-Level Abstractions:</strong> Libraries like OData build upon
                        LINQ's <code>IQueryable</code> foundation.</li>
                </ul>
                <p>Mastering LINQ is still a critical skill for any .NET developer, providing a powerful,
                    expressive, and type-safe way to work with data.</p>
            </div>
        </div>

        <!-- Appendices -->
        <div class="chapter">
            <h2 class="text-3xl font-bold">Appendices</h2>

            <div class="section">
                <h3 id="appendix-a" class="text-2xl font-semibold">Appendix A: LINQ Quick Reference Guide</h3>
                <p>Common Standard Query Operators (Method Syntax)</p>
                <table>
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Operator</th>
                            <th>Description</th>
                            <th>Query Syntax Equivalent</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Filtering -->
                        <tr>
                            <td rowspan="2">Filtering</td>
                            <td><code>Where</code></td>
                            <td>Filters a sequence based on a predicate.</td>
                            <td><code>where</code></td>
                        </tr>
                        <tr>
                            <td><code>OfType</code></td>
                            <td>Filters elements based on their type.</td>
                            <td>N/A</td>
                        </tr>
                        <!-- Projection -->
                        <tr>
                            <td rowspan="2">Projection</td>
                            <td><code>Select</code></td>
                            <td>Projects each element into a new form.</td>
                            <td><code>select</code></td>
                        </tr>
                        <tr>
                            <td><code>SelectMany</code></td>
                            <td>Projects elements to sequences and flattens them.</td>
                            <td>Multiple <code>from</code> clauses</td>
                        </tr>
                        <!-- Sorting -->
                        <tr>
                            <td rowspan="4">Sorting</td>
                            <td><code>OrderBy</code></td>
                            <td>Sorts elements in ascending order.</td>
                            <td><code>orderby ... ascending</code></td>
                        </tr>
                        <tr>
                            <td><code>OrderByDescending</code></td>
                            <td>Sorts elements in descending order.</td>
                            <td><code>orderby ... descending</code></td>
                        </tr>
                        <tr>
                            <td><code>ThenBy</code></td>
                            <td>Performs a subsequent ascending sort.</td>
                            <td><code>orderby ..., ... ascending</code></td>
                        </tr>
                        <tr>
                            <td><code>ThenByDescending</code></td>
                            <td>Performs a subsequent descending sort.</td>
                            <td><code>orderby ..., ... descending</code></td>
                        </tr>
                        <!-- Grouping -->
                        <tr>
                            <td>Grouping</td>
                            <td><code>GroupBy</code></td>
                            <td>Groups elements based on a key.</td>
                            <td><code>group ... by ...</code></td>
                        </tr>
                        <!-- Joining -->
                        <tr>
                            <td rowspan="2">Joining</td>
                            <td><code>Join</code></td>
                            <td>Performs an inner join based on matching keys.</td>
                            <td><code>join ... in ... on ... equals ...</code></td>
                        </tr>
                        <tr>
                            <td><code>GroupJoin</code></td>
                            <td>Groups elements based on key matches; used for left joins.</td>
                            <td><code>join ... in ... on ... equals ... into ...</code></td>
                        </tr>
                        <!-- Set Operations -->
                        <tr>
                            <td rowspan="5">Set Operations</td>
                            <td><code>Distinct</code> / <code>DistinctBy</code></td>
                            <td>Returns distinct elements from a sequence.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Union</code> / <code>UnionBy</code></td>
                            <td>Returns the set union of two sequences.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Intersect</code> / <code>IntersectBy</code></td>
                            <td>Returns the set intersection of two sequences.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Except</code> / <code>ExceptBy</code></td>
                            <td>Returns the set difference of two sequences.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Concat</code></td>
                            <td>Concatenates two sequences (preserves duplicates).</td>
                            <td>N/A</td>
                        </tr>
                        <!-- Partitioning -->
                        <tr>
                            <td rowspan="5">Partitioning</td>
                            <td><code>Take</code> / <code>TakeLast</code></td>
                            <td>Takes a specified number of elements from the start/end.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Skip</code> / <code>SkipLast</code></td>
                            <td>Skips a specified number of elements from the start/end.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>TakeWhile</code></td>
                            <td>Takes elements while a condition is true.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>SkipWhile</code></td>
                            <td>Skips elements while a condition is true.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Chunk</code></td>
                            <td>Splits the sequence into chunks of a specified size.</td>
                            <td>N/A</td>
                        </tr>
                        <!-- Element Operations -->
                        <tr>
                            <td rowspan="4">Element Operations</td>
                            <td><code>First</code> / <code>FirstOrDefault</code></td>
                            <td>Returns the first element (optionally matching a predicate).</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Last</code> / <code>LastOrDefault</code></td>
                            <td>Returns the last element (optionally matching a predicate).</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Single</code> / <code>SingleOrDefault</code></td>
                            <td>Returns the only element (optionally matching a predicate); throws if not exactly
                                one.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>ElementAt</code> / <code>ElementAtOrDefault</code></td>
                            <td>Returns the element at a specific index.</td>
                            <td>N/A</td>
                        </tr>
                        <!-- Quantifiers -->
                        <tr>
                            <td rowspan="3">Quantifiers</td>
                            <td><code>Any</code></td>
                            <td>Checks if any element exists or satisfies a predicate.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>All</code></td>
                            <td>Checks if all elements satisfy a predicate.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Contains</code></td>
                            <td>Checks if a sequence contains a specific element.</td>
                            <td>N/A</td>
                        </tr>
                        <!-- Aggregation -->
                        <tr>
                            <td rowspan="6">Aggregation</td>
                            <td><code>Count</code> / <code>LongCount</code></td>
                            <td>Counts the number of elements (optionally matching a predicate).</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Sum</code></td>
                            <td>Computes the sum of a sequence of numeric values.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Average</code></td>
                            <td>Computes the average of a sequence of numeric values.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Min</code> / <code>MinBy</code></td>
                            <td>Finds the minimum value or element based on a selector.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Max</code> / <code>MaxBy</code></td>
                            <td>Finds the maximum value or element based on a selector.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>Aggregate</code></td>
                            <td>Performs a custom aggregation operation.</td>
                            <td>N/A</td>
                        </tr>
                        <!-- Conversion -->
                        <tr>
                            <td rowspan="5">Conversion</td>
                            <td><code>ToList</code>, <code>ToArray</code></td>
                            <td>Materializes the query into a List or Array.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>ToDictionary</code></td>
                            <td>Materializes the query into a Dictionary.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>ToHashSet</code></td>
                            <td>Materializes the query into a HashSet.</td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>ToLookup</code></td>
                            <td>Materializes the query into a Lookup (similar to Dictionary<TKey, IEnumerable<TValue>>).
                            </td>
                            <td>N/A</td>
                        </tr>
                        <tr>
                            <td><code>AsEnumerable</code>, <code>AsQueryable</code></td>
                            <td>Casts or converts the type of the sequence.</td>
                            <td>N/A</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="section">
                <h3 id="appendix-b" class="text-2xl font-semibold">Appendix B: C# 14 Features Relevant to LINQ
                    (Projected)</h3>
                <p>While specific C# 14 features are pending official release, based on trends from C# 12 and 13
                    previews, here are features likely relevant to LINQ usage:</p>
                <ul class="list-disc pl-8 mb-4">
                    <li><strong>Collection Expressions (`[...]`, `..`):</strong> (C# 12) Unified syntax for creating
                        arrays, lists, spans. Simplifies source data creation and inline collection usage in LINQ.
                    </li>
                    <li><strong>Primary Constructors:</strong> (C# 12 for classes/structs) Concise syntax for
                        defining types, ideal for DTOs used in LINQ projections (<code>Select</code>).</li>
                    <li><strong>Default Lambda Parameters:</strong> (C# 12) Allows optional parameters in lambda
                        expressions, potentially useful in custom LINQ extensions or complex predicates.</li>
                    <li><strong>`params` enhancements (e.g., `params Span<T>`):</strong> Could allow more efficient
                        passing of data to methods potentially used within LINQ chains, reducing allocations.</li>
                    <li><strong>Potential Pattern Matching Enhancements:</strong> Further improvements to property,
                        list, or type patterns could make `Where` clauses or `Select` transformations more
                        expressive.</li>
                    <li><strong>Refined `ref readonly` parameters:</strong> Might enable more efficient passing of
                        data structures within LINQ pipelines without copying, especially for struct-heavy code.
                    </li>
                    <li><strong>Compiler Optimizations:</strong> Ongoing improvements in how the C# compiler
                        optimizes code, including LINQ query translations and lambda implementations.</li>
                </ul>
                <pre><code class="language-csharp">// Example Recap: C# 12 features enhancing LINQ

        // Collection Expressions
        var source = [10, 20, 30, 40];
        var filtered = source.Where(x => x > 25).ToList(); // Uses [] syntax

        // Primary Constructor for DTO
        public record PointInfo(int X, int Y);
        var pointInfos = source.Chunk(2).Select(pair => new PointInfo(pair[0], pair[1]));

        // Default Lambda Parameter
        Func<int, int, int> addOrDefault = (x, y = 10) => x + y;
        var addedResults = source.Select(n => addOrDefault(n)); // Uses default y=10
        </code></pre>
            </div>

            <div class="section">
                <h3 id="appendix-c" class="text-2xl font-semibold">Appendix C: Case Studies</h3>

                <h4 class="text-xl font-medium mt-6">Case Study 1: Log File Analysis</h4>
                <p><strong>Problem:</strong> Analyze a large web server log file (text format) to find the top 10
                    most frequent IP addresses accessing a specific resource path, excluding requests with error
                    status codes (5xx).</p>
                <pre><code class="language-csharp">// Simulate log lines: IP Address - - [DateTime] "Request" StatusCode Bytes
        IEnumerable<string> GetLogLines() {
            yield return "192.168.1.1 - - [18/May/2024:...] \"GET /api/users HTTP/1.1\" 200 1024";
            yield return "10.0.0.5 - - [18/May/2024:...] \"POST /api/orders HTTP/1.1\" 201 512";
            yield return "192.168.1.1 - - [18/May/2024:...] \"GET /api/users HTTP/1.1\" 200 1024";
            yield return "172.16.0.10 - - [18/May/2024:...] \"GET /images/logo.png HTTP/1.1\" 200 4096";
            yield return "192.168.1.1 - - [18/May/2024:...] \"GET /api/users HTTP/1.1\" 500 100"; // Error
            yield return "10.0.0.5 - - [18/May/2024:...] \"GET /api/products HTTP/1.1\" 200 8192";
            yield return "192.168.1.1 - - [18/May/2024:...] \"GET /api/users HTTP/1.1\" 200 1024";
            yield return "10.0.0.5 - - [18/May/2024:...] \"GET /api/users HTTP/1.1\" 200 1024";
            // ... potentially millions more lines
        }

        string targetPath = "/api/users";

        var topIPs = GetLogLines()
            .Select(line => line.Split(' ', StringSplitOptions.RemoveEmptyEntries)) // Crude split
            .Where(parts => parts.Length >= 10) // Basic validation
            .Select(parts => new { // Project to structured data
                IpAddress = parts[0],
                Request = parts[6], // Assuming fixed format "GET /path HTTP/1.1"
                StatusCode = int.TryParse(parts[8], out int code) ? code : 0
            })
            .Where(log => log.Request == targetPath) // Filter by target path
            .Where(log => log.StatusCode < 500) // Exclude server errors
            .GroupBy(log => log.IpAddress) // Group by IP address
            .Select(group => new { // Calculate count for each IP
                IpAddress = group.Key,
                Count = group.Count()
            })
            .OrderByDescending(result => result.Count) // Order by frequency
            .Take(10) // Get top 10
            .ToList(); // Materialize the result

        Console.WriteLine($"--- Top IPs Accessing {targetPath} (excluding 5xx errors) ---");
        foreach (var entry in topIPs)
        {
            Console.WriteLine($"- IP: {entry.IpAddress}, Count: {entry.Count}");
        }
        </code></pre>
                <div class="code-result">
                    --- Top IPs Accessing /api/users (excluding 5xx errors) ---
                    - IP: 192.168.1.1, Count: 3
                    - IP: 10.0.0.5, Count: 1
                </div>

                <h4 class="text-xl font-medium mt-6">Case Study 2: Order Fulfillment Prioritization</h4>
                <p><strong>Problem:</strong> Given a list of orders, prioritize them for fulfillment. High-priority
                    orders (marked explicitly) come first, then orders with expedited shipping, then orders sorted
                    by oldest date first.</p>
                <pre><code class="language-csharp">public record OrderInfo(int Id, DateTime OrderDate, bool IsHighPriority, bool HasExpeditedShipping);

        List<OrderInfo> orders = [
            new(101, DateTime.Now.AddDays(-2), false, false),
            new(102, DateTime.Now.AddDays(-1), true, false), // High priority
            new(103, DateTime.Now.AddDays(-3), false, true),  // Expedited
            new(104, DateTime.Now.AddDays(-1), false, true),  // Expedited, newer
            new(105, DateTime.Now.AddHours(-2), false, false), // Newest standard
            new(106, DateTime.Now.AddDays(-5), false, false), // Oldest standard
            new(107, DateTime.Now.AddDays(-1), true, true)   // High priority & Expedited
        ];

        var prioritizedOrders = orders
            .OrderByDescending(o => o.IsHighPriority) // High priority first (true > false)
            .ThenByDescending(o => o.HasExpeditedShipping) // Then Expedited (true > false)
            .ThenBy(o => o.OrderDate) // Then by oldest date (ascending)
            .Select(o => $"ID: {o.Id} (HP: {o.IsHighPriority}, Exp: {o.HasExpeditedShipping}, Date: {o.OrderDate:yyyy-MM-dd HH:mm})")
            .ToList();

        Console.WriteLine("\n--- Prioritized Order Fulfillment List ---");
        foreach (var orderDesc in prioritizedOrders)
        {
            Console.WriteLine($"- {orderDesc}");
        }
        </code></pre>
                <div class="code-result">
                    --- Prioritized Order Fulfillment List ---
                    - ID: 107 (HP: True, Exp: True, Date: 2024-05-17 14:16) <!-- Example Date -->
                    - ID: 102 (HP: True, Exp: False, Date: 2024-05-17 14:16) <!-- Example Date -->
                    - ID: 103 (HP: False, Exp: True, Date: 2024-05-15 14:16) <!-- Example Date -->
                    - ID: 104 (HP: False, Exp: True, Date: 2024-05-17 14:16) <!-- Example Date -->
                    - ID: 106 (HP: False, Exp: False, Date: 2024-05-13 14:16) <!-- Example Date -->
                    - ID: 101 (HP: False, Exp: False, Date: 2024-05-16 14:16) <!-- Example Date -->
                    - ID: 105 (HP: False, Exp: False, Date: 2024-05-18 12:16) <!-- Example Date -->
                </div>

                <h4 class="text-xl font-medium mt-6">Case Study 3: Finding Common Interests</h4>
                <p><strong>Problem:</strong> Given lists of interests for several users, find interests common to at
                    least N users.</p>
                <pre><code class="language-csharp">Dictionary<string, List<string>> userInterests = new() {
            ["Alice"] = ["Reading", "Hiking", "Movies", "Coding"],
            ["Bob"] = ["Hiking", "Gaming", "Movies", "Music"],
            ["Charlie"] = ["Cooking", "Hiking", "Reading", "Music"],
            ["David"] = ["Gaming", "Movies", "Hiking", "Reading"]
        };
        int minCommonUsers = 3;

        var commonInterests = userInterests
            .SelectMany(kvp => kvp.Value) // Flatten all interests into one list
            .GroupBy(interest => interest) // Group by interest name
            .Where(group => group.Count() >= minCommonUsers) // Filter groups with enough users
            .Select(group => group.Key) // Select the interest name (the key)
            .ToList();

        Console.WriteLine($"\n--- Interests Common to at Least {minCommonUsers} Users ---");
        Console.WriteLine(string.Join(", ", commonInterests));
        </code></pre>
                <div class="code-result">
                    --- Interests Common to at Least 3 Users ---
                    Reading, Hiking, Movies
                </div>
            </div>
        </div>

        <footer class="mt-12 pt-6 border-t border-gray-300 text-center text-gray-600">
            <p> 2024 Mohamed Fazrin Mohamed Farook Quadrate Tech Solutions. Happy LINQing!</p>
        </footer>

    </div> <!-- End book-container -->

    <!-- Prism JS for syntax highlighting -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    <!-- Ensure languages you need are loaded or use autoloader -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-clike.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-csharp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-bash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.24.1/components/prism-sql.min.js"></script>
    <script>
        // Optional: You might need to manually trigger highlighting if content is loaded dynamically
        // Prism.highlightAll();
    </script>
</body>

</html>